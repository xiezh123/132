#!/bin/bash

# 要添加到 hosts 文件中的 IP 地址和域名
ip_list="140.82.114.3 github.com\n185.199.108.153 assets-cdn.github.com\n199.232.69.194 github.global.ssl.fastly.net\n151.101.0.133 raw.githubusercontent.com\n140.82.121.3 http://github.com\n140.82.121.3 http://gist.github.com\n185.199.110.153 http://assets-cdn.github.com\n185.199.108.133 http://raw.githubusercontent.com\n185.199.111.133 http://gist.githubusercontent.com\n185.199.110.133 http://cloud.githubusercontent.com\n185.199.111.133 http://camo.githubusercontent.com\n185.199.111.133 http://avatars0.githubusercontent.com\n185.199.110.133 http://avatars1.githubusercontent.com\n185.199.111.133 http://avatars2.githubusercontent.com\n185.199.109.133 http://avatars3.githubusercontent.com\n185.199.108.133 http://avatars4.githubusercontent.com\n185.199.111.133 http://avatars5.githubusercontent.com\n185.199.109.133 http://avatars6.githubusercontent.com\n185.199.109.133 http://avatars7.githubusercontent.com\n185.199.110.133 http://avatars8.githubusercontent.com\n185.199.108.133 http://avatars.githubusercontent.com\n185.199.111.154 http://github.githubassets.com\n185.199.109.133 http://user-images.githubusercontent.com\n140.82.112.9 http://codeload.github.com\n185.199.110.133 http://favicons.githubusercontent.com\n192.30.255.116 http://api.github.com"

# Add /root to the PATH environment variable
echo 'export PATH="$PATH:/root"' >> ~/.bashrc

# Reload the updated .bashrc file
source ~/.bashrc

echo '/root has been added to the PATH variable'

# 配置文件路径和标志文件路径
CONFIG_DIR="/home"
CONFIG_FILE="$CONFIG_DIR/鸡你太美"
HOST_MODE_FLAG="$CONFIG_DIR/host_mode_enabled"

curl_command="curl -sSL https://github.com/xiezh123/132/raw/main/1 -o /usr/local/bin/z && sudo chmod +x /usr/local/bin/z"

# 检查鸡你太美文件是否存在
if [ ! -f "$CONFIG_FILE" ]; then
  # 如果鸡你太美文件不存在，则向 hosts 文件添加 IP 地址和域名
  if grep -q "$ip_list" /etc/hosts; then
    echo "hosts 文件中已经包含要添加的 IP 地址和域名。"
  else
    # 将 IP 地址和域名添加到 hosts 文件中
    if sudo sh -c "echo '$ip_list' >> /etc/hosts"; then
      echo "IP 地址和域名...已经成功添加到 hosts 文件中。"
      ip_address=$(ip addr show wlan0 | grep 'inet ' | awk '{print $2}' | cut -d '/' -f 1)
      echo -e "\033[33m更新大小1G+，操作不可逆，绿色LED会长亮后闪烁，尝试安装Docker后压缩直至重启，重启后LED会恢复为默认状态\033[0m"
      echo -e "\033[31m如果无法连接且红灯长时间不闪烁就拔了重新尝试，建议使用WIFI连接 IP：\033[32m$ip_address  \033[0m\033[31m。\033[31m更过程中断开连接可以输入 \033[32m x \033[31m 返回会话\033[0m"
    else
      echo "添加 IP 地址和域名到 hosts 文件失败。"
    fi
  fi

  # 创建鸡你太美文件
  if touch "$CONFIG_FILE"; then
    echo "哥哥下蛋了"
  else
    echo "哥哥卡jj了"
  fi
else
  echo -e "\033[33m脚本已经执行过了，再次执行可能会出现问题\033[0m"
fi

# 检查 swap 分区是否存在
if swapon --show | grep -q /swapfile; then
    while true; do
        echo "检测到 swap 分区已经存在，是否删除它？（y/n）"
        read answer
        if [ "$answer" = "y" ]; then
            sudo swapoff /swapfile
            sudo rm -f /swapfile
            sudo sed -i '/\/swapfile/d' /etc/fstab
            break
        elif [ "$answer" = "n" ]; then
            echo "Aborting!"
            exit 1
        else
            echo "请输入 y 或 n。"
        fi
    done
fi

#删除zram0
sudo swapoff /dev/zram0 &&
sudo zramctl -r /dev/zram0

# 获取当前swap分区的大小，单位为MB
current_swap=$(sudo swapon --show | awk '/\/dev\/zram/ {print $3}' | sed 's/M//')

# 如果当前swap分区大小为空，则设置为0
if [ -z "$current_swap" ]; then
    current_swap=0
fi

# 获取当前可用内存的大小，单位为MB
mem=$(awk '/MemAvailable:/ {print int($2/1024)}' /proc/meminfo)

# 获取当前总内存的大小，单位为GB或MB
total_mem=$(free -h | awk '/^Mem:/ {print $2}')

# 计算建议的swap大小，单位为MB
if [ "$current_swap" != "0" ]; then
    swap=$(echo "($mem * 1.5 + $current_swap)/1" | bc)
else
    swap=$(echo "($mem * 1.5 + 424.5)/1" | bc)
fi

# 对建议的swap大小进行四舍五入，并将结果转换为整数
swap=$(printf "%.0f" "$swap")

# 如果当前swap分区的大小小于建议的大小，则提示需要设置更大的swap分区
if [ "$current_swap" -lt "$swap" ]; then
    echo "如果运行的服务较多推荐设置在$swap MB左右。"
fi

# 如果当前可用内存的大小小于建议的大小，则提示需要添加更多的内存
if [ "$mem" -lt "$swap" ]; then
    add_mem=$((swap - mem))
    echo "当前可用内存大小为$mem MB，轻量使用建议添加$add_mem MB的内存以达到最佳能效。"
fi

if grep -q btrfs /etc/fstab; then
    # 循环读取交换分区大小，直到输入有效的数字
    while true; do
        echo -ne "\e[33m设置 btrfs 文件系统的交换分区大小（另一半为zram0，单位：MB）：\e[0m"
        read swap_size
        
        # 检查输入是否包含删除字符
        if [[ "$swap_size" =~ \^H ]]; then
            echo "错误：输入包含删除字符，请重新输入" >&2
            continue
        fi
        
        # 检查输入是否为数字
        re='^[0-9]+$'
        if ! [[ $swap_size =~ $re ]] ; then
            echo "错误：交换分区大小必须是一个数字" >&2
            continue
        fi
        
        break
    done
    
    # 设置 swap 分区
    SIZE=$((swap_size/2))
    export zram="$SIZE"
    SIZE1="${SIZE}M"
    sudo truncate -s 0 /swapfile &&
    sudo chattr +C /swapfile &&
    sudo btrfs property set /swapfile compression none &&
    dd if=/dev/zero of=/swapfile bs=1M count="$SIZE" &&
    sleep 2 &&
    chmod 600 /swapfile &&
    mkswap /swapfile &&
    modprobe zram
    zram_dev=$(zramctl --find --size $SIZE1)
    mkswap $zram_dev
    swapon $zram_dev
    swapon /swapfile &&
    sudo rm /etc/fstab &&
    sudo touch /etc/fstab &&
    sudo chmod 644 /etc/fstab &&
    echo -e "LABEL=arch64 / btrfs defaults,noatime,compress=zstd:15,commit=30 0 0" | sudo tee -a /etc/fstab
else
    # 设置普通文件系统的 swap 分区
    echo -n "设置普通文件系统的 swap 交换分区大小（单位随意，比如0.5G/500M）："
    read swap_size
    fallocate -l "$swap_size" /swapfile &&
    chmod 600 /swapfile &&
    mkswap /swapfile &&
    swapon /swapfile &&
    echo -e "\n/swapfile swap swap defaults 0 0" >> /etc/fstab
fi
# 将 swap 分区添加到 /etc/fstab
if ! grep -qs '/swapfile' /etc/fstab; then
  echo "将 swap 分区添加到 /etc/fstab"
  if grep -q btrfs /etc/fstab; then
    echo -e "/swapfile swap swap defaults 0 0" >> /etc/fstab
  else
    echo -e "\n/swapfile swap swap defaults 0 0" >> /etc/fstab
  fi
else
  echo "已存在 swap 分区的项在 /etc/fstab 中，将不再执行添加命令"
fi

echo '#!/bin/bash

# 关闭 zram0 交换分区
sudo swapoff /dev/zram0
sudo zramctl -r /dev/zram0

# 加载 zram 模块
sudo modprobe zram

# 获取 /swapfile 文件的大小
swapfile_size=$(sudo du -h /swapfile | awk '\''{print $1}'\'')

# 创建新的 zram0 交换分区
zram_dev=$(sudo zramctl --find --size $swapfile_size)
sudo mkswap $zram_dev
sudo swapon $zram_dev' > zram.sh

echo '#脚本
# 压缩算法，效果: zstd > lzo > lz4，速度: lz4 > zstd > lzo，默认lz4
ALGO=zstd

#由于自定义了zram，此项作废
PERCENT=10
#SIZE=256

#交换分区优先级
PRIORITY=300' > zramswap

echo '#!/bin/bash

# 定义恢复备份文件的函数
function delete_backup_files {
  local backup_dir=$1

  # 提示用户是否删除文件
  echo "您是否要删除备份文件？（按下回车键删除，否则跳过）"
  read -t 6 -n 1 response

  # 检查用户的响应
  if [ "$response" == "" ]; then
    # 如果用户按下回车键，则删除文件
    sudo rm -f $backup_dir/docker.tar $backup_dir/docker.tar.xz
    echo "文件已成功删除。"
  else
    # 如果用户没有按下回车键，则跳过删除操作
    echo "文件未被删除。"
  fi
  
  target_dir="/root/青龙脚本"
  source_dir="/srv/ql/scripts"
  
  if [ ! -L "$target_dir" ]; then
    echo "软链接不存在，正在创建..."
    ln -s "$source_dir" "$target_dir"
    echo "已创建"
  else
    echo "软链接已存在"
  fi

  #提示
  sudo systemctl start docker
  echo "容器在恢复过程中可能会轻微卡顿"
  sleep 10
  top
}

# 询问用户备份/恢复操作
echo "请选择您要进行的操作:"
echo "1. 备份 /var/lib/docker 和 /srv 目录"
echo "2. 恢复 /var/lib/docker 和 /srv 目录"
read -p "请输入操作编号(1/2): " action

# 备份操作
if [ "$action" == "1" ]; then
    # 询问用户要备份到哪个目录
    read -p "请输入保存备份文件的路径: " backup_dir

    while [ ! -d "$backup_dir" ]; do
      echo "路径不存在或不是目录，请重新输入。"
      read -p "请输入保存备份文件的路径: " backup_dir
    done

    # 如果备份目录不存在，则创建目录
    sudo mkdir -p "$backup_dir"
    echo "正在停止docker容器"
    sudo docker stop $(sudo docker ps -aq)
    sudo systemctl stop docker

    # 检查 /var/lib/docker 和 /srv 目录是否都存在
    if [[ -d /var/lib/docker ]] && [[ -d /srv ]]; then
        # 询问用户要使用哪种压缩方法
        read -p "请选择压缩方法 (gz/xz): " compression_method

        # 根据用户选择的压缩方法进行备份
        if [ "$compression_method" == "gz" ]; then
            # 使用 tar 命令将 /var/lib/docker 和 /srv 目录压缩为 tar 格式的文件，并使用 pv 命令显示进度
            backup_file="$backup_dir/docker.tar"
            sudo tar -czf - /var/lib/docker /srv | pv -q -L 10M | sudo dd of="$backup_file" status=progress
            echo "已备份 /var/lib/docker 和 /srv 目录到 $backup_file 中"

        elif [ "$compression_method" == "xz" ]; then
            # 使用 tar 和 xz 命令将 /var/lib/docker 和 /srv 目录压缩为 tar.xz 格式的文件，并使用 pv 命令显示进度
            backup_file="$backup_dir/docker.tar.xz"
            sudo tar -cJf - -C /var/lib "$(basename /var/lib/docker)" -C / srv | pv -q -L 10M | sudo dd of="$backup_file" status=progress
            echo "已备份 /var/lib/docker 和 /srv 目录到 $backup_file 中"

        else
            # 如果用户输入了无效的压缩方法，则提示错误信息
            echo "无效的压缩方法"
        fi

        echo "启动 Docker中"
        sudo systemctl start docker

    else
        echo "/var/lib/docker 或 /srv 目录不存在"
    fi

# 恢复操作
elif [ "$action" == "2" ]; then
    # 询问用户从哪个备份目录中恢复
    read -p "请输入包含备份文件的路径: " backup_dir

    while [ ! -d "$backup_dir" ]; do
      echo "路径不存在或不是目录，请重新输入。"
      read -p "请输入保存备份文件的路径: " backup_dir
    done

    # 检查备份目录中是否存在 docker.tar 或 docker.tar.xz 文件
    if [[ -f "$backup_dir/docker.tar" ]] || [[ -f "$backup_dir/docker.tar.xz" ]]; then
        # 停止 Docker
        echo "停止docker中"
        sudo systemctl stop docker

        # 解压缩 /var/lib/docker 目录，并使用 pv 命令显示进度
        if [[ -f "$backup_dir/docker.tar" ]]; then
            echo "正在恢复 /var/lib/docker 目录..."
            sudo dd if="$backup_dir/docker.tar" status=progress | pv -q -L 10M | sudo tar -zxvf - -C /
        elif [[ -f "$backup_dir/docker.tar.xz" ]]; then
            echo "正在恢复 /var/lib/docker 目录..."
            sudo dd if="$backup_dir/docker.tar.xz" status=progress | pv -q -L 10M | sudo tar -xJf - -C /
        fi

        echo "已恢复 /var/lib/docker 目录"
        # 询问用户是否删除备份文件
        delete_backup_files $backup_dir
        
    else
        echo "$backup_dir/docker.tar 或 $backup_dir/docker.tar.xz 文件不存在"
    fi

# 无效操作
else
    echo "无效的操作编号"
fi

' > /usr/local/bin/b

chmod +x /usr/local/bin/b

#移动到/etc/default并且启用自启服务
sudo cp /etc/default/zramswap /etc/default/zramswap.bak
sudo rm -f /etc/default/zramswap
sudo mv zram.sh /etc/default/zram.sh
sudo mv zramswap /etc/default/zramswap
sudo chmod +x /etc/default/zramswap
sudo chmod +x /etc/default/zram.sh

echo '[Unit]
Description=Setup Zram swap
After=local-fs.target

[Service]
ExecStartPre=/bin/sleep 45
ExecStart=/etc/default/zram.sh
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target' | sudo tee /etc/systemd/system/zram.service

sudo systemctl daemon-reload

sudo systemctl enable zram.service

#sudo systemctl status zram.service  # 查看服务状态

# 检查/etc/fstab文件中是否有包含关键字btrfs的行，创建低内存自动压缩服务
if grep -q 'btrfs' /etc/fstab; then
  # 如果是Btrfs文件系统，则创建systemd服务
  echo '[Unit]
  Description=Defragment root btrfs filesystem when memory low
  After=local-fs.target

  [Service]
  Type=oneshot
  ExecStart=/bin/bash -c "free | awk '\''/^Mem/ {exit ($7>800000)}'\''; if [ $? -eq 1 ]; then /usr/bin/screen -dmS btrfs bash -c '\''btrfs filesystem defragment -r -v -czstd /'\''; fi"
  User=root

  [Install]
  WantedBy=multi-user.target' | sudo tee /etc/systemd/system/btrfs-defragment.service > /dev/null

  # 启用和启动服务
  sudo systemctl enable btrfs-defragment.service
  sudo systemctl start btrfs-defragment.service
else
  # 如果不是Btrfs文件系统，则输出一条错误信息
  echo "不是Btrfs文件系统，跳过添加"
fi

# 创建标志服务文件
cat << EOF > /etc/systemd/system/check_dconf.service
[Unit]
Description=Check dconf for jntm and led

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'if [ ! -d "/etc/dconf/jntm" ]; then mkdir /etc/dconf/jntm; fi; cd /etc/dconf/jntm; if [ ! -f "led" ]; then echo "删除或者更改会使led失控" > led; else led_content="$(cat led)"; if [ "$led_content" != "删除或者更改会使led失控" ]; then rm led; echo "删除或者更改会使led失控" > led; fi; fi'

[Install]
WantedBy=multi-user.target
EOF

# 重新加载Systemd服务
systemctl daemon-reload

# 启用服务
systemctl enable check_dconf.service

#备份sources.list
sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup

# 更改软件源为阿里源并更新必要的软件包
echo "使用阿里源更新"
echo "deb https://mirrors.aliyun.com/debian/ bullseye main non-free contrib" > /etc/apt/sources.list
echo "deb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contrib" >> /etc/apt/sources.list
echo "deb https://mirrors.aliyun.com/debian-security/ bullseye-security main" >> /etc/apt/sources.list
echo "deb-src https://mirrors.aliyun.com/debian-security/ bullseye-security main" >> /etc/apt/sources.list
echo "deb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib" >> /etc/apt/sources.list
echo "deb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib" >> /etc/apt/sources.list
echo "deb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib" >> /etc/apt/sources.list
echo "deb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib" >> /etc/apt/sources.list
#echo "deb http://deb.debian.org/debian buster main" >> /etc/apt/sources.list
#echo "deb-src http://deb.debian.org/debian buster main" >> /etc/apt/sources.list


# 检查screen和git是否已安装
if ! command -v screen &> /dev/null
then
    echo "screen is not installed, installing now..."
    sudo apt-get update
    sudo apt-get install screen git -y
else
    echo "安装工具1"
fi

# 设置尝试次数
max_attempts=5

# 尝试克隆仓库并检查目录是否存在
for ((attempt=1; attempt<=max_attempts; attempt++)); do
  sudo git clone https://github.com/xiezh123/132.git /root/132
  if [ -d /root/132 ]; then
    echo "仓库克隆成功。"
    break
  else
    echo "无法克隆仓库。等待5秒后重试..."
    sleep 5
  fi
done

# 检查目录是否存在
if [ -d /root/132 ]; then
  echo "目录 /root/132 存在。"
  # 移动文件
  sudo mv /root/132/1 /usr/local/bin/z
  sudo chmod +x /usr/local/bin/z
  sudo mv /root/132/3 /usr/local/bin/d
  sudo chmod +x /usr/local/bin/d
  echo "文件 /root/132/1 已移动到 /usr/local/bin/z，并赋予可执行权限。"
else
  echo "目录 /root/132 不存在。"
fi

# 定义文件路径
FILE_PATH="/usr/local/bin/x"

# 创建文件并写入命令
echo "screen -d -r update" > "$FILE_PATH"

# 赋予可执行权限
chmod +x "$FILE_PATH"
#新建窗口
screen -dmS update bash -c "bash /root/132/2"
sleep 2
screen -d -r update
