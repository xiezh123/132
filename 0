#!/bin/bash

################################################################################################################################################################################设置自启
function quick_reboot {

        script_path=$(dirname "$(realpath "$0")")
        script_name=$(basename "$0")
        # 执行函数后退出脚本
        sudo chmod +x $script_path/$script_name
        # 要插入的命令
        insert_command="sleep 15 && bash $script_path/$script_name"
        # rc.local 文件路径
        rc_local_file="/etc/rc.local"
        # 检查 rc.local 文件是否存在
        if [ -f "$rc_local_file" ]; then
            # 检查插入的命令是否已存在
            if grep -q "$insert_command" "$rc_local_file"; then
                echo "命令已存在于 rc.local 文件中."
            else
                # 在 exit 0 之前插入命令，并且备份
                sudo cp /etc/rc.local /etc/rc.local.backup
                sed -i "/exit 0/i $insert_command" "$rc_local_file"
                echo "已插入命令到 rc.local 文件.开机25秒后执行$script_path/$script_name"
            fi
        else
            echo "rc.local 文件不存在."
        fi
        sleep 1 # 等待
        sudo mv "$script_path/4gwifi" /var/log/
        sleep 1 # 等待
        echo -e "\033[1;33m$script_path/4gwifi已经移动到/var/log，即将执行重启！\033[0m"
        sleep 3 # 等待
        countdown2=5

        echo "按回车键以执行关机操作"
        echo "（$countdown2 秒后自动停止脚本）"

        for ((i=$countdown2; i>=1; i--)); do
            echo -ne "倒计时: $i \r"
            sleep 1

            # 检查用户输入
            if read -r -t 1 -s -N 1 input; then
                if [[ $input == $'\x0a' ]]; then
                    echo "执行关机操作..."
                    echo host > /sys/kernel/debug/usb/ci_hdrc.0/role
                    systemctl suspend
                    exit 0
                fi
            fi
        done

        echo "倒计时结束，执行重启"
        /sbin/reboot
        exit 0

}
# 网络连通性检测
host_number() {
                        sleep 3
                        # 执行 ifconfig 命令并将输出保存到变量中
                        output=$(ifconfig usb0)
                        sleep 1
                        echo none > /sys/class/leds/blue\:wifi/trigger #蓝灯
                        echo none > /sys/class/leds/green\:internet/trigger #绿灯
                        # 使用 grep 命令在输出中查找目标字符串
                        if echo "$output" | grep -q "inet 10.42.0.1"; then
                            echo "usb0 接口具有ip内容，接口处于使用状态，将保持状态"
                            echo cpu > /sys/class/leds/green\:internet/trigger
                        else
                            echo "usb0 接口没有ip内容，接口处于未使用状态，切换主机模式"
                            echo host > /sys/kernel/debug/usb/ci_hdrc.0/role
                            sudo sh -c "echo timer > /sys/class/leds/blue\:wifi/trigger && echo 500 > /sys/class/leds/blue\:wifi/delay_on && echo 500 > /sys/class/leds/blue\:wifi/delay_off" && sleep 1
                            sleep 6
                        fi
                        sleep 3
                        echo "测试更新中"
                        # 清空 /etc/apt/sources.list 文件内容
                        echo "" > /etc/apt/sources.list
                        # 添加清华大学开源软件镜像站的源到 /etc/apt/sources.list 文件
                        echo "deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free" > /etc/apt/sources.list
                        echo "deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list
                        check_update_status() {
                            local update_output="$1"
                            if apt list --upgradable | grep -qE '^.+/.+ '; then
                                if echo "$update_output" | grep -q "暂时不能解析域名"; then
                                    echo "需要重启"
                                    quick_reboot
                                else
                                    apt list --upgradable
                                    echo "当前状态可以更新"
                                    export Network=1
                                fi
                            else
                                if echo "$update_output" | grep -q "正在读取软件包列表" && echo "$update_output" | grep -q "正在分析软件包的依赖关系树" && echo "$update_output" | grep -q "正在读取状态信息" && echo "$update_output" | grep -q "所有软件包均为最新"; then
                                    echo "所有软件包均为最新。"
                                else
                                    echo "更新软件包..."
                                    # 执行更新软件包的操作
                                    export Network=1
                                fi
                            fi
                        }
                        # 执行 apt update 命令，并将输出直接显示在终端上
                        update_output=$(apt update 2>&1 | tee /dev/tty)
                        ping -c 1 www.baidu.com > /dev/null  # 发送一个ping请求到百度
                        if [ $? -eq 0 ]; then
                            echo "通过"
                            if [[ -z "${SH}" ]]; then
                                echo "环境变量 SH 不存在。"
                            else
                                #环境变量 SH 存在
                                check_update_status "$update_output"
                            fi
                        else
                            sleep 3
                            ping -c 1 www.baidu.com > /dev/null
                            if [ $? -eq 0 ]; then
                                echo "第一次尝试通过"
                            else
                                ping -c 1 8.8.8.8 > /dev/null  # 发送一个ping请求到谷歌
                                if [ $? -eq 0 ]; then
                                    echo "第二次尝试通过"
                                    check_update_status "$update_output"
                                else
                                    if [[ -z "${SH}" ]]; then
                                        echo "环境变量 SH 不存在。"
                                    else
                                        #环境变量 SH 存在
                                        /sbin/reboot
                                    fi
                                    echo "第三次ping测试失败，没有网络？？？"
                                    check_update_status "$update_output"
                                    sudo sh -c "echo timer > /sys/class/leds/blue\:wifi/trigger && echo 1000 > /sys/class/leds/blue\:wifi/delay_on && echo 1000 > /sys/class/leds/blue\:wifi/delay_off"
                                    count=0
                                    max_attempts=$((15 * 60 / 5))  # 15分钟内的最大尝试次数
                                    echo none > /sys/class/leds/green\:internet/trigger #绿灯
                                    while true; do
                                    if ping -c 1 www.baidu.com > /dev/null; then
                                        echo "Ping 成功。"
                                        export Network=1
                                        break
                                    else
                                        count=$((count + 1))

                                        if [ $count -eq $max_attempts ]; then
                                            echo "15分钟内未能成功Ping。执行系统挂起操作。"
                                            systemctl suspend
                                            break
                                        fi

                                        echo -e "\033[31mPing 失败。6秒后重试...（请查看网络是否正常）\033[0m"
                                        sleep 6
                                        echo 255 > /sys/class/leds/mmc0\:\:/brightness
                                    fi
                                    done
                                fi
                            fi
                        fi
                        echo phy0tx > /sys/class/leds/blue\:wifi/trigger

}

################################################################################################################################################################################设置sawp

function skip_swap_setup {

  
  # 检查 swap 分区是否存在
  if swapon --show | grep -q /swapfile; then
      while true; do
          echo "检测到 swap 分区已经存在，是否删除它？（y/n）"
          read answer
          if [ "$answer" = "y" ]; then
              sudo swapoff /swapfile
              sudo rm -f /swapfile
              sudo sed -i '/\/swapfile/d' /etc/fstab
              break
          elif [ "$answer" = "n" ]; then
              echo "Aborting!"
              exit 1
          else
              echo "请输入 y 或 n。"
          fi
      done
  fi
  # 获取当前swap分区的大小，单位为MB
  current_swap=$(sudo swapon --show | awk '/\/dev\/zram/ {print $3}' | sed 's/M//')
  # 如果当前swap分区大小为空，则设置为0
  if [ -z "$current_swap" ]; then
      current_swap=0
  fi
  # 获取当前可用内存的大小，单位为MB
  mem=$(awk '/MemAvailable:/ {print int($2/1024)}' /proc/meminfo)
  # 获取当前总内存的大小，单位为GB或MB
  total_mem=$(free -h | awk '/^Mem:/ {print $2}')
  # 计算建议的swap大小，单位为MB
  if [ "$current_swap" != "0" ]; then
      swap=$(echo "($mem * 1.5 + $current_swap)/1" | bc)
  else
      swap=$(echo "($mem * 1.5 + 424.5)/1" | bc)
  fi
  # 对建议的swap大小进行四舍五入，并将结果转换为整数
  swap=$(printf "%.0f" "$swap")
  # 如果当前swap分区的大小小于建议的大小，则提示需要设置更大的swap分区
  if [ "$current_swap" -lt "$swap" ]; then
      echo "如果运行的服务较多推荐设置在$swap MB左右。"
  fi
  # 如果当前可用内存的大小小于建议的大小，则提示需要添加更多的内存
  if [ "$mem" -lt "$swap" ]; then
      add_mem=$((swap - mem))
      echo -e "当前可用内存大小为${mem} MB，轻量使用建议添加\e[32m${add_mem}\e[0m MB的内存以达到最佳能效。\033[K"
  fi
  # 添加检查/4gwifi文件，如果不在/log目录则视为手动配置
  # 检查文件是否存在
  if [[ -e "/var/log/4gwifi" ]]; then
      echo "文件 /var/log/4gwifi 存在"
      if grep -q "^vswap=" "/etc/environment"; then
          # 读取变量大小
          vswap_value=$(grep "^vswap=" "/etc/environment" | cut -d= -f2-)
          echo "在 /etc/environment 中找到变量 vswap，其大小为: $vswap_value"
          if [ "$vswap_value" -ge 300 ]; then
              # 大于或等于 300
              export JNTM=0
          else
              # 小于 300
              export JNTM=1
          fi
      else
          sudo sh -c 'echo "vswap='"${add_mem}"'" >> /etc/environment'
      fi
  else
      echo "文件 /var/log/4gwifi 不存在"
  fi
  
}

########################################################################################################################################################################################

# 交换分区和启动命令
sys1() {

script_content="#!/bin/bash

sudo cpufreq-set -g performance
echo 0 > /sys/class/leds/green\\:internet/brightness
sleep 1
echo timer > /sys/class/leds/green\\:internet/trigger
export end=0

# 函数：增加 log 值并执行测试命令
update_log_and_run_test() {
  log_file=\"/root/log.txt\"
  # 检查 log 文件是否存在，如果不存在则创建并初始化为 1
  if [ ! -f \"\$log_file\" ]; then
    echo \"1\" > \"\$log_file\"
  fi

  # 读取 log 文件的当前值
  current_value=\$(<\"\$log_file\")

  # 将值加一
  new_value=\$((current_value + 1))

  # 将新值写回 log 文件
  echo \"\$new_value\" > \"\$log_file\"

  # 在这里添加您的测试命令
  # 您可以使用 \$new_value 变量来获取 log 文件的当前值

  # 示例：打印 log 文件的当前值
  echo \"当前值：\$new_value\"
}

# 如果需要更改分区大小可以更改变量数字为vswap，重启会创建新的大小
# 检查 /etc/environment 文件中的 swap 变量
if grep -qE '^swap=' /etc/environment; then
    # 找到变量
    if grep -q 'swap' /etc/fstab; then
        # 获取 /dev/zram0 设备的大小
        zram_size=\$(blockdev --getsize64 /dev/zram0 | numfmt --to=iec)
        # 获取 /swapfile 文件的大小
        swapfile_size=\$(ls -lh /swapfile | awk '{print \$5}')
        # 去除大小值中的单位
        zram_size=\${zram_size//M/}
        swapfile_size=\${swapfile_size//M/}
        # 将两个大小值相加
        total_size=\$((zram_size + swapfile_size))
        # 从 /etc/environment 获取 vswap 的值
        vswap_value=\$(grep -E '^swap=' /etc/environment | cut -d '=' -f 2)
        echo \"total_size: \$total_size\"
        echo \"vswap_value: \$vswap_value\"
        # 比较大小值是否相等
        if [ \"\$total_size\" -eq \"\$vswap_value\" ]; then
            echo \"已设置zram0交换分区。\"
        else
            # 关闭 zram0 交换分区
            sudo swapoff /dev/zram0
            sudo zramctl -r /dev/zram0
            # 加载 zram 模块
            sudo modprobe zram
            # 获取 /swapfile 文件的大小
            swapfile_size=\$(sudo du -h /swapfile | awk '{print \$1}')
            # 创建新的 zram0 交换分区
            zram_dev=\$(sudo zramctl --find --size \$swapfile_size)
            sudo mkswap \$zram_dev
            sudo swapon \$zram_dev
        fi
    else
        # 设置两倍zram0 交换分区
        # 获取当前 zram0 交换分区的大小
        zram0_size1=\$(blockdev --getsize64 /dev/zram0)
        # 关闭 zram0 交换分区
        sudo swapoff /dev/zram0
        # 删除 zram0 设备
        sudo zramctl -r /dev/zram0
        # 创建两倍大小的新 zram0 交换分区
        new_zram0_size1=\$((2 * zram0_size1))
        sudo zramctl --find --size \$new_zram0_size1
        # 格式化 zram0 交换分区
        sudo mkswap /dev/zram0
        # 启用新的 zram0 交换分区
        sudo swapon /dev/zram0
    fi
else
    # 检查 /etc/environment 文件中的 vswap 变量，# 没有找到变量，查找vswap变量
    vswap_value=\$(grep -E '^vswap=' /etc/environment | cut -d '=' -f 2)

    if [ -n \"\$vswap_value\" ]; then
        echo \"在 /etc/environment 文件中找到 vswap 变量，其值为: \$vswap_value\"
        if grep -q 'swap' /etc/fstab; then
            echo \"Swap 分区已存在。\"
            #关闭swap
            swapoff /swapfile
            #删除
            rm -f /swapfile
            # 检查 /etc/fstab 文件中是否包含关键字 \"btrfs\"
            if grep -q 'btrfs' /etc/fstab; then
                echo \"正在设置swap分区，zrm0在更新重启后会自动启用\"
                # 清空 swapfile
                sudo truncate -s 0 /swapfile
                # 设置 swapfile 不可压缩
                sudo chattr +C /swapfile
                # 禁用 swapfile 压缩
                sudo btrfs property set /swapfile compression none
                # 从文件中读取 count 值
                count=\$((\$vswap_value / 2))
                # 向 swapfile 增加空间
                dd if=/dev/zero of=/swapfile bs=1M count=\$count
                # 设置 swapfile 权限
                sudo chmod 600 /swapfile
                # 创建 swap 区
                sudo mkswap /swapfile
                # 启用 swap
                sudo swapon /swapfile
                ## 添加开机启用
                if grep -q \"compress=zstd:15,commit=30 0 0\" \"/etc/fstab\"; then
                  echo \"找到关键字\"
                else
                  sudo echo -n > /etc/fstab
                  echo -e \"LABEL=arch64 / btrfs defaults,noatime,compress=zstd:15,commit=30 0 0\" | sudo tee -a /etc/fstab
                fi
            else
                # 从文件中读取大小值
                size=\$((\$vswap_value / 2))
    
                # 检查大小值是否符合要求
                if [[ \$size =~ ^[0-9]+(\.[0-9]+)?[MG]\$ && \$(echo \$size | sed 's/[0-9.]//g') != \"GG\" && \$(echo \$size | sed 's/[0-9.]//g') != \"MM\" && \$(echo \$size | sed 's/[0-9.]//g') != \"GM\" ]]; then
                    # 创建 swapfile
                    fallocate -l \$size /swapfile
                    # 设置正确的权限
                    chmod 600 /swapfile
                    # 格式化 swap 文件
                    mkswap /swapfile
                    # 启用 swap 文件
                    swapon /swapfile
                    echo \"脚本执行成功！Swap 文件大小为 \$size\"
                else
                    echo \"文件内容错误，请检查 /root/wifi 文件的第 3 行内容！\"
                fi
            fi
        fi
        # 关闭 zram0 交换分区
        sudo swapoff /dev/zram0
        sudo zramctl -r /dev/zram0
        # 加载 zram 模块
        sudo modprobe zram
        # 获取 /swapfile 文件的大小
        swapfile_size=\$(sudo du -h /swapfile | awk '{print \$1}')
        # 创建新的 zram0 交换分区
        zram_dev=\$(sudo zramctl --find --size \$swapfile_size)
        sudo mkswap \$zram_dev
        sudo swapon \$zram_dev
        sleep 3
        # 获取 /dev/zram0 设备的大小
        zram_size=\$(blockdev --getsize64 /dev/zram0 | numfmt --to=iec)
        # 获取 /swapfile 文件的大小
        swapfile_size=\$(ls -lh /swapfile | awk '{print \$5}')
        # 去除大小值中的单位
        zram_size=\${zram_size//M/}
        swapfile_size=\${swapfile_size//M/}
        # 将两个大小值相加
        total_size=\$((zram_size + swapfile_size))
        # 从 /etc/environment 获取 vswap 的值
        vswap_value=\$(grep -E '^vswap=' /etc/environment | cut -d '=' -f 2)
        # 比较大小值是否相等
        if [ \"\$total_size\" -eq \"\$vswap_value\" ]; then
            # 已将 vswap 替换为 swap
            sudo sed -i 's/^vswap=/swap=/' /etc/environment
        else
            echo \"交换分区和 zram0 交换分区大小之和不等于 vswap 的值。\"
        fi
    else
        echo \"Swap 分区不存在。\"
    fi
    echo \"在 /etc/environment 文件中未找到 vswap 变量。\"
fi

if ! grep -qs '/swapfile' /etc/fstab; then
  echo \"将 swap 分区添加到 /etc/fstab\"
  if grep -q btrfs /etc/fstab; then
    echo -e \"/swapfile swap swap defaults 0 0\" >> /etc/fstab
  else
    echo -e \"\n/swapfile swap swap defaults 0 0\" >> /etc/fstab
  fi
else
  echo \"已存在 swap 分区的项在 /etc/fstab 中，将不再执行添加命令\"
fi
swap_value=\$(grep -oP '(?<=^swap=).*' /etc/environment)
# 检查swap变量是否小于300
if (( swap_value < 300 )); then
    # swap变量小于300
    export 4GWiFi1=1
else
    # swap变量大于等于300
    export 4GWiFi1=0
fi
######################################################
# 设置热点
wifisys() {

        # 检查 /etc/environment 文件是否含有变量 4Gwifi
        if grep -q \"4Gwifi=\" /etc/environment; then
            # 执行 nmcli connection show 命令，并将输出保存到变量中
            output=\$(nmcli connection show)
            # 检查是否存在包含 \"modem\" 的连接
            connection_name=\$(echo \"\$output\" | awk '/modem/ {print \$1}')
            if [ -n \"\$connection_name\" ]; then
              # 检查连接是否已激活
              active_connection=\$(echo \"\$output\" | awk '/[[:space:]]+connected[[:space:]]+/ {print \$1}')
              if [ \"\$active_connection\" == \"\$connection_name\" ]; then
                echo -e \"连接已经激活: \e[32m\$active_connection\e[0m\"
              else
                # 激活连接
                nmcli connection up \"\$connection_name\"
                echo -e \"已激活连接: \e[32m\$connection_name\e[0m\"
              fi
            else
              echo \"未找到包含 'modem' 的连接\"
            fi
            sleep 1
            # 执行 nmcli connection show 命令，并将输出保存到变量中
            output=\$(nmcli connection show)

            # 检查输出是否包含 hotspot 变量的值
            if [[ \$output =~ \$hotspot ]]; then
                # 查找名字以 wifi. 或 wifi- 开头的文件，并匹配 hotspot 变量
                files=\$(ls /etc/NetworkManager/system-connections/ | grep -E '^wifi(\.|-).*' | grep -v \"\$hotspot\")
                # 删除匹配的文件（保留 hotspot 对应的文件）
                for file in \$files; do
                    rm \"/etc/NetworkManager/system-connections/\$file\"
                done
                # 执行 nmcli 连接热点
                hotspot=\"\$hotspot\" nmcli connection up \"\$hotspot\"
            else
                # 读取 /etc/environment 文件中的 4Gwifi 变量
                four_g_wifi=\$(grep -oP '^4Gwifi=\K.*' /etc/environment)
                # 拆分名字和密码
                IFS='//' read -r name password <<< \"\$four_g_wifi\"
                # 输出名字和密码
                echo \"名字: \$name3\"
                echo \"密码: \$password3\"
                # 如果不一致则启用热点并且向 \$hotspot 写入新的 UUID
                output3=\$(nmcli d wifi hotspot ifname wlan0 con-name wifi ssid \"\$name3\" band bg channel 11 password \"\$password3\") # 更改名字密码为变量
                # 提取连接的 UUID
                uuid1=\$(echo \"\${output3}\" | awk '{print \$2}')
                # 去除双引号和前缀 \"wlan0\"
                uuid1=\${uuid1//\"/}
                uuid1=\${uuid1#wlan0}
                # 去除另一行的 \"nmcli\"
                uuid1=\$(echo \"\$uuid1\" | sed '/^\$/d' | sed 's/nmcli//g')
                # 将 UUID 写入文件
                echo \"\$uuid1\"
                # 检查 /etc/environment 文件是否存在
                if [[ -f /etc/environment ]]; then
                    # 检查 /etc/environment 文件中是否已经定义了变量 \$hotspot
                    if grep -q \"^hotspot=\" /etc/environment; then
                        # 如果已经定义了变量 \$hotspot，则使用 sed 命令进行替换
                        sed -i \"s/^hotspot=.*/hotspot=\$uuid1/\" /etc/environment
                    else
                        # 如果没有定义变量 \$hotspot，则在文件末尾添加新的变量定义
                        echo \"hotspot=\$uuid1\" >> /etc/environment
                    fi
                fi
            fi
        else
            echo \"变量 4Gwifi 不存在。跳过创建热点。\"
        fi
        # 检查环境变量的值
        if [[ \"\${4GWIFI1}\" == \"1\" ]]; then
            echo \"环境变量4GWIFI1的值为 1\"
        elif [[ \"\${4GWIFI1}\" == \"0\" ]]; then
            # 环境变量4GWIFI1的值为 0
            output5=\$(byobu-enable 2>&1)
            if [[ \$output5 == *\"byobu-disable\"* ]]; then
                echo \"Byobu 已启用\"
                byobu-disable
                sleep 1
                byobu-enable
            else
                echo \"Byobu 未启用\"
                byobu-disable
                sleep 1
                byobu-enable
            fi
        else
            echo \"环境变量4GWIFI1的值不是 1 也不是 0\"
        fi


}
sleep 5
################################################# 调用函数
cpusys() {

echo none > /sys/class/leds/green\\:internet/trigger
sleep 1
export end=1
echo timer > /sys/class/leds/green\\:internet/trigger

# 设置 LED 设备路径
led_device=\"/sys/class/leds/green:internet\"

# 获取当前 CPU 占用率
cpu_usage=\$(top -bn1 | grep \"Cpu(s)\" | awk '{print \$2}' | awk -F. '{print \$1}')

# 定义 CPU 占用率阈值和 LED 闪烁频率的关系
cpu_threshold=50  # CPU 占用率阈值，超过该值 LED 闪烁频率会增加
min_delay=100  # 最小延迟（单位：毫秒），LED 闪烁的最低频率
max_delay=1000  # 最大延迟（单位：毫秒），LED 闪烁的最高频率

# 根据 CPU 占用率计算 LED 闪烁频率
if [[ \$cpu_usage -gt \$cpu_threshold ]]; then
  # 根据 CPU 占用率和阈值的关系计算延迟值
  cpu_delay=\$((min_delay + (max_delay - min_delay) * (cpu_usage - cpu_threshold) / (100 - cpu_threshold)))

  # 将延迟值应用到 LED 设备
  echo \$cpu_delay > \"\$led_device/delay_on\"
  echo \$cpu_delay > \"\$led_device/delay_off\"
elif [[ \$cpu_usage -lt 15 ]]; then
  # CPU 占用率低于 15% 时，将 LED 设备触发器模式设置为 \"heartbeat\"
  echo none > /sys/class/leds/green\\:internet/trigger
  sleep 1
  echo heartbeat > \"\$led_device/trigger\"
fi

# 显示 CPU 占用率
echo \"CPU 占用率: \$cpu_usage%\"

}

pingwifi() {
	
# Ping 百度网站并执行相应操作
if ping -c 1 www.baidu.com >/dev/null 2>&1; then
    # 检查 Docker 是否已安装
    if command -v docker &> /dev/null; then
        if systemctl is-enabled docker &> /dev/null; then
            systemctl disable docker
        else
            systemctl start docker
        fi
    else
        echo \"Docker 未安装，跳过...\"
    fi
    #bash /etc/dconf/jntm/push.sh
    echo none > /sys/class/leds/blue\\:wifi/trigger
    sleep 2
    echo phy0tx > /sys/class/leds/blue\\:wifi/trigger
else
    echo none > /sys/class/leds/blue\\:wifi/trigger
    sleep 1
    echo none > /sys/class/leds/green\\:internet/trigger
    sleep 1
    sudo sh -c \"echo timer > /sys/class/leds/blue\\:wifi/trigger && echo 500 > /sys/class/leds/blue\\:wifi/delay_on && echo 500 > /sys/class/leds/blue\\:wifi/delay_off\" && sleep 1
fi

}

# 定义循环函数 run_loop
run_loop() {
    export end=1
    while true; do
        current_time3=\$(date +%H:%M)  # 获取当前时间，格式为小时:分钟

        # 在这里写入您想要执行的命令
        cpusys
        sleep 2
        pingwifi
        # 获取系统平均负载计算led频率
        # 添加条件来停止循环
        if [[ \$current_time3 > \"02:20\" && \$current_time3 < \"02:30\" ]]; then
            break
            if [[ \$(grep -c btrfs /proc/mounts) -gt 0 ]]; then
              btrfs filesystem defragment -r -v -czstd / && sleep 6
            else
              echo \"系统文件不是btrfs，取消执行压缩系统命令\"
            fi
            f
        fi

        sleep 60  # 等待 60 秒
    done
}


# 读取中央处理器温度控制led频率
run_loop2() {

export end=1

while true; do
    # 获取 CPU 温度
    cpu_temp=\$(cat /sys/class/thermal/thermal_zone0/temp)
    cpu_temp=\$((cpu_temp / 1000))  # 转换为摄氏度
    # 读取触发器名称
    trigger_command=\$(cat \"/sys/class/leds/green:internet/trigger\")
    trigger_name=\$(echo \"\$trigger_command\" | awk -F '\\\\[' '{print \$2}' | awk -F '\\\\]' '{print \$1}')

    echo \"LED触发器名称: \$trigger_name\"

    # 检查 CPU 温度是否超过 65 度
    if [[ \$cpu_temp -gt 65 ]]; then
        # CPU 温度超过 65 度
        # 设置 LED 快速闪烁
        if [ \"\$trigger_name\" != \"timer\" ]; then
            sudo sh -c \"echo timer > /sys/class/leds/green:internet/trigger && echo 200 > /sys/class/leds/green:internet/delay_on && echo 200 > /sys/class/leds/green:internet/delay_off\"
            echo \"超过65\"
        fi
    else
        # CPU 温度没有超过 65 度
        if [ \"\$trigger_name\" != \"heartbeat\" ]; then
            echo heartbeat > /sys/class/leds/green:internet/trigger
            echo \"低于65\"
        fi
    fi
    update_log_and_run_test #########################
    sleep 60  # 等待 50 秒
done
}

ledsy() {

sleep 1

# 读取 /etc/environment 文件中的环境变量
while read -r line; do
    export \"\$line\"
done < /etc/environment

# 使用读取的环境变量
echo \"LED 环境变量的值是：\$LED\"
# 检查 LED 环境变量的值并显示相应的提示
if [[ \"\$LED\" == \"0\" ]]; then
    echo \"LED 的值为 0\"
    export end=1
    echo 0 > /sys/class/leds/mmc0\\:\\:/brightness #红灯
    echo none > /sys/class/leds/blue\\:wifi/trigger #蓝灯
    echo none > /sys/class/leds/green\\:internet/trigger #绿灯
    exit 0
else
    # 检查文件夹是否存在
    #if [[ \"\$Host\" == \"1\" ]]; then
        #echo 0 > /sys/class/leds/green\\:internet/brightness
    #else
        #echo timer > /sys/class/leds/green\\:internet/trigger
    #fi
    pingwifi
    if [ -d \"/etc/dconf/jntm\" ]; then
        echo \"文件夹 /etc/dconf/jntm 已存在.\"
    
        # 检查文件是否存在
        if [ -f \"/etc/dconf/jntm/led\" ]; then
            echo \"文件 /etc/dconf/jntm/led 已存在.\"
        else
            echo \"文件 /etc/dconf/jntm/led 不存在，创建文件...\"
            touch \"/etc/dconf/jntm/led\"
            echo \"文件 /etc/dconf/jntm/led 创建成功.\"
        fi
    else
        mkdir -p \"/etc/dconf/jntm\"
        touch \"/etc/dconf/jntm/led\"
        echo \"文件夹 /etc/dconf/jntm 及文件 /etc/dconf/jntm/led 创建成功.\"
    fi
    sudo cpufreq-set -g ondemand
    
    # 读取环境变量 host
    host_value=\"\$host\"
    # 检查 host 的值
    if [[ \"\$host_value\" == \"1\" ]]; then
        # host 的值为 1
        run_loop
    elif [[ \"\$host_value\" == \"0\" ]]; then
        # host 的值为 0
        run_loop2
    else
        echo \"host 的值既不是 1 也不是 0\"
    fi
fi

}
######################################################
nmcli radio wifi off
update_log_and_run_test #########################
sudo sed -i 's/^reboot0=.*/reboot0=0/' /etc/environment

sudo sed -i 's/^LEDoff=.*/LEDoff=0/' /etc/environment
sleep 5
nmcli radio wifi on
update_log_and_run_test #########################
sleep 2
# 执行 ifconfig 命令并将输出保存到变量中
output=\$(ifconfig usb0)
sleep 2
# 使用 grep 命令在输出中查找目标字符串
if echo \"\$output\" | grep -q \"inet 10.42.0.1\"; then
    sudo sed -i 's/^Host=.*/Host=0/' /etc/environment
    export host=0
    update_log_and_run_test #########################
else
    # 启用主机模式
    echo host > /sys/kernel/debug/usb/ci_hdrc.0/role
    sleep 2
    echo none > /sys/class/leds/green\\:internet/trigger && sleep 1
    sleep 2
    sudo sed -i 's/^Host=.*/Host=1/' /etc/environment
    sleep 2
    # 执行 fdisk -l 命令并将结果保存到变量中
    output=\$(fdisk -l)
    export host=1
    sleep 5
    # 使用正则表达式匹配设备信息，并将匹配结果保存到数组中
    regex='/dev/sda1\s+[0-9]+\s+[0-9]+\s+[0-9]+\s+([0-9.]+[KMG]?)\s+Linux filesystem'
    devices=()
    while read -r line; do
        if [[ \$line =~ \$regex ]]; then
            size=\${BASH_REMATCH[1]}
            devices+=(\"\$line\")
        fi
    done <<< \"\$output\"

    # 挂载设备
    if [ \${#devices[@]} -gt 0 ]; then
        echo \"找到以下设备：\"
        for device in \"\${devices[@]}\"; do
            echo \"\$device\"
            # 提取设备路径
            device_path=\$(echo \"\$device\" | awk '{print \$1}')
            # 创建挂载点目录
            mount_point=\"/mnt/\$(basename \"\$device_path\")\"
            echo \"将 \$device_path 挂载到 \$mount_point\"
            mkdir -p \"\$mount_point\"
            # 挂载设备
            mount \"\$device_path\" \"\$mount_point\"
        done
    else
        echo \"未找到匹配的设备。\"
    fi
fi

sleep 1
while true; do
    # 检查环境变量 end 是否为 1
    if [ \"\$end\" = \"1\" ]; then
        echo \"结束循环\"
        sleep 1
        sudo systemctl stop zram.service
        break
    fi
    update_log_and_run_test #########################
    # 在这里编写您想要循环执行的代码
    ledsy
    pingwifi
    # 等待一段时间
    sleep 5
done
##################################################################################读取环境变量查询是否为主机模式，是则执行run_loop和run_loop2函数
##################################################################################添加开机自动检测SIM卡并且查看是否符合开热点的条件，添加swap是否符合要求，否则不执行某一项命令
exit 0"

echo "$script_content" > zram.sh

# Create zram.service file
cat << EOL > /etc/systemd/system/zram.service
[Unit]
Description=Setup Zram swap
After=local-fs.target

[Service]
ExecStartPre=/bin/sleep 25
ExecStart=$jntm_path/zram.sh
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOL

# Enable zram.service
systemctl daemon-reload
systemctl enable zram.service

script_path="/usr/local/bin/u"
script_content0='#!/bin/bash

# 设置尝试次数
max_attempts=3
attempt=1
while [ $attempt -le $max_attempts ]; do
    # 执行wget命令下载文件
    wget "https://raw.githubusercontent.com/xiezh123/132/main/1" -O "/usr/local/bin/z"
    
    # 检查文件是否为空文件
    if [ -s "/usr/local/bin/z" ]; then
        echo "文件已成功下载并不为空。"
        break
    else
        echo "文件为空或下载失败。尝试重新下载（尝试次数：$attempt）。"
        attempt=$((attempt+1))
    fi
done
if [ $attempt -gt $max_attempts ]; then
    echo "无法下载文件。尝试次数已达到上限。"
fi'

echo "$script_content0" > "$script_path"
chmod +x "$script_path"

}

syssys() {
######################################################################################## Led控制

sys3() {
  echo '#!/bin/bash

# 读取 /etc/environment 文件中的环境变量
while read -r line; do
    export "$line"
done < /etc/environment

# 检查 LED 环境变量的值并显示相应的提示
if [[ "$LED" == "1" ]]; then
    echo "LED 的值为 1"
    export LEDOFF=0
else
    export LEDOFF=1
fi

# 定义LED控制函数
led_control() {

  sudo sh -c "echo phy0tx > /sys/class/leds/blue\:wifi/trigger && echo mmc0 > /sys/class/leds/mmc0\:\:/trigger"
  
  # 获取温度值
  temp=$(cat /sys/class/thermal/thermal_zone0/temp)
  
  # 取头值
  head=${temp:0:1}
  
  # 如果第二位大于5，则头值加1
  if [ ${temp:1:1} -ge 5 ]; then
    head=$((head+1))
  fi
  
  # 如果头值小于5，则退出脚本
  if [ $head -lt 5 ]; then
    echo "头值小于5，停止执行脚本。"
    exit 1
  fi
    
  echo 255 > /sys/class/leds/green:internet/brightness
  
  sleep 3

  echo 0 > /sys/class/leds/green:internet/brightness

  sleep 2
  
  # 计算循环次数和间隔时间
  count=$head
  interval=$((15/(count*2)))
  
  # 循环执行命令
  for ((i=1; i<=$count; i++)); do
    echo 255 > /sys/class/leds/green:internet/brightness
    sleep $interval
    echo 0 > /sys/class/leds/green:internet/brightness
    sleep $interval
  done
  
  # 关闭亮灯
  echo 0 > /sys/class/leds/green:internet/brightness
}

#检查
check_led_trigger() {
  # 检查环境变量内容是否为"1"
  if [[ "$LEDOFF" == "1" ]]; then
      exit 1
  else
      echo "LED环境变量的值不是1"
  fi
  
  echo "绿色 LED 触发器状态不为 none，开始执行 led_control 命令..."
  led_control
  echo "led_control 命令执行完毕。"
  exit 0
}

#检查wifi
check_led_nowifi() {
  # 检查环境变量内容是否为"1"
  if [[ "$LEDOFF" == "1" ]]; then
      exit 1
  else
      echo "LEDoff环境变量的值不是1"
  fi
  
  echo "绿色 LED 触发器状态不为 none，开始执行 led_control 命令..."
  sudo sh -c "echo timer > /sys/class/leds/blue\:wifi/trigger && echo 1500 > /sys/class/leds/blue\:wifi/delay_on && echo 1500 > /sys/class/leds/blue\:wifi/delay_off && echo 255 > /sys/class/leds/mmc0\:\:/brightness && echo timer > /sys/class/leds/green:internet/trigger && echo 1500 > /sys/class/leds/green\:internet/delay_on && echo 1500 > /sys/class/leds/green\:internet/delay_off"
  echo "led_control 命令执行完毕。"
  exit 0
}

#开关wifi
function wifi_reconnect {
    ping -c 3 www.baidu.com > /dev/null 2>&1

    if [ $? -ne 0 ]; then
        echo "WiFi连接已断开，正在尝试重新连接..."
        nmcli radio wifi off
        sleep 5
        nmcli radio wifi on
        sleep 10
        ping -c 3 www.baidu.com > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            echo "WiFi重新连接成功。"
        else
            echo "WiFi重新连接失败。"
        fi
    fi
}

#写入日志
function write_wifi_log() {
# 检查wifi.log文件是否存在
if [ ! -e /etc/dconf/jntm/wifi.log ]; then
    touch /etc/dconf/jntm/wifi.log
    echo "$(date +%Y-%m-%d\ %H:%M:%S): wifi.log does not exist, creating one." >> /var/log/wifi.log
fi

# 判断执行次数是否达到10次
if [ ! -e /etc/dconf/jntm/opweroff ]; then
    if [ ! -e /var/log/count.log ]; then
        echo "0" > /var/log/count.log
    fi

    count=$(cat /var/log/count.log)
    count=$((count+1))
    echo $count > /var/log/count.log

    if [ "$count" -eq 10 ]; then
        # 创建opweroff文件
        touch /etc/dconf/jntm/opweroff
        # 执行函数1
        /sbin/reboot
    fi
else
    # 删除创建的文件
    rm -f /var/log/count.log
    rm -f /etc/dconf/jntm/wifi.log
    rm -f /etc/dconf/jntm/opweroff

    # 检查网络连接是否畅通
    if ping -c 1 www.baidu.com &> /dev/null; then
        exit 0 # 如果网络畅通，则停止执行
    fi

    # 执行函数2
    sleep 2
    systemctl suspend

fi
}

#删除wifilog
function remove_wifi_log() {
    logfile="/etc/dconf/jntm/wifi.log"

    # 检查 log 文件是否存在，如果存在则删除
    if [ -e "${logfile}" ]; then
        rm "${logfile}"
    fi
    if [ -e /var/log/count.log ]; then
        rm -f /var/log/count.log
    fi
    
    if [ -e /etc/dconf/jntm/wifi.log ]; then
        rm -f /etc/dconf/jntm/wifi.log
    fi
    
    if [ -e /etc/dconf/jntm/opweroff ]; then
        rm -f /etc/dconf/jntm/opweroff
    fi
}

if [[ "$GREEN_TRIGGER" == "none" && "$BLUE_TRIGGER" == "none" ]]; then
    echo "LED触发器状态为none，不进行碎片整理操作。"
else
    if ping -c 1 www.baidu.com > /dev/null 2>&1; then
        echo "网络连接正常，重置指示灯"
        check_led_trigger
        remove_wifi_log
    else
        echo "没有网络连接，执行操作"
        write_wifi_log
        check_led_nowifi
        wifi_reconnect
    fi
fi
' > /etc/dconf/jntm/LEDnetwork.sh

echo "#!/bin/bash

uptime_output=\$(uptime)
uptime_info=\"\"

# 解析开机时间
uptime=\$(echo \"\$uptime_output\" | awk -F \"up \" '{print \$2}' | awk -F \",\" '{print \$1}' | sed 's/^[[:space:]]*//')
uptime_info+=\"当前系统已经开机 \$uptime，\"

# 解析登录用户数
users=\$(echo \"\$uptime_output\" | awk -F \", \" '{print \$2}' | awk '{print \$1}')
uptime_info+=\"当前登录用户数为 \$users 个，\"

# 解析负载平均值
load_average=\$(echo \"\$uptime_output\" | awk -F \"load average: \" '{print \$2}')
load_average_info=\"系统的负载平均值为：\$load_average\"

uptime_info+=\$load_average_info

echo \"\$uptime_info\"

function dockersys {
# 获取 Docker 所有容器 ID
container_ids=\$(docker ps -aq)

if [[ -z \"\$container_ids\" ]]; then
    echo \"没有找到任何正在运行的 Docker 容器。\"
else
    # 逐个退出容器
    for container_id in \$container_ids; do
        echo \"正在退出容器: \$container_id\"
        docker stop \$container_id
    done

    echo \"所有容器已成功退出。\"
fi
# 关闭 Docker
echo \"正在关闭 Docker 服务...\"
systemctl stop docker
}

# 获取当前时间的小时和分钟
current_hour=\$(date +%H)
current_minute=\$(date +%M)

# 检查是否为半夜 2 点 30 分
if [[ \$current_hour -eq 2 && \$current_minute -eq 30 ]]; then
    dockersys
    btrfs filesystem defragment -r -v -czstd /
    reboot
else
    echo 1 > /proc/sys/vm/drop_caches
    dockersys
    poweroff
fi" > /usr/local/bin/f

echo '#脚本
# 压缩算法，效果: zstd > lzo > lz4，速度: lz4 > zstd > lzo，默认lz4
ALGO=zstd

#由于自定义了zram，此项作废
PERCENT=10
#SIZE=256

#交换分区优先级
PRIORITY=300' > zramswap

######################################网络

# 要添加到 hosts 文件中的 IP 地址和域名
ip_list="157.148.69.80 www.baidu.com\n182.89.194.244 mirrors.aliyun.com\n140.82.114.3 github.com\n185.199.108.153 assets-cdn.github.com\n199.232.69.194 github.global.ssl.fastly.net\n151.101.0.133 raw.githubusercontent.com\n140.82.121.3 http://github.com\n140.82.121.3 http://gist.github.com\n185.199.110.153 http://assets-cdn.github.com\n185.199.108.133 http://raw.githubusercontent.com\n185.199.111.133 http://gist.githubusercontent.com\n185.199.110.133 http://cloud.githubusercontent.com\n185.199.111.133 http://camo.githubusercontent.com\n185.199.111.133 http://avatars0.githubusercontent.com\n185.199.110.133 http://avatars1.githubusercontent.com\n185.199.111.133 http://avatars2.githubusercontent.com\n185.199.109.133 http://avatars3.githubusercontent.com\n185.199.108.133 http://avatars4.githubusercontent.com\n185.199.111.133 http://avatars5.githubusercontent.com\n185.199.109.133 http://avatars6.githubusercontent.com\n185.199.109.133 http://avatars7.githubusercontent.com\n185.199.110.133 http://avatars8.githubusercontent.com\n185.199.108.133 http://avatars.githubusercontent.com\n185.199.111.154 http://github.githubassets.com\n185.199.109.133 http://user-images.githubusercontent.com\n140.82.112.9 http://codeload.github.com\n185.199.110.133 http://favicons.githubusercontent.com\n192.30.255.116 http://api.github.com"

echo "$ip_list" | sudo tee -a /etc/hosts
  
echo "正在更改DNS服务器..."
echo "nameserver 180.76.76.76" | sudo tee -a /etc/resolv.conf
echo "nameserver 180.76.76.67" | sudo tee -a /etc/resolv.conf
echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf
echo "nameserver 8.8.4.4" | sudo tee -a /etc/resolv.conf
echo "nameserver 223.5.5.5" | sudo tee -a /etc/resolv.conf
echo "nameserver 223.6.6.6" | sudo tee -a /etc/resolv.conf

}
#######################################################################################推送脚本
push0() {

sudo tee /etc/dconf/jntm/push.sh <<EOF
#!/bin/bash
#code by Aimt#

# 读取 /etc/environment 文件中的环境变量
while read -r line; do
    export "$line"
done < /etc/environment

# 将自己的token复制到这里 eg.MyToken="123456xxxx"
MyToken="$PushToken"

cpu_usage=\$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - \$1}')
memory_usage=\$(free -m | awk 'NR==2{printf "%s/%sMB (%.2f%%)\n", \$3,\$2,\$3*100/\$2 }')
network_traffic=\$(/sbin/ifconfig enx00e04c360017 | awk '/RX p/{print \$6,\$7}')

push_body="服务器{\$(hostname)}状态信息：\n\n"
push_body+="公网IP：\$(curl -s cip.cc | awk 'NR==1{printf \$3}')\n"
push_body+="局域网IP：\$(hostname -I | awk '{print \$1}')\n"
push_body+="USB网卡IP：\$(ifconfig usb0 | awk '/inet /{print \$2}')\n"
push_body+="CPU温度：\$(cat /sys/class/thermal/thermal_zone0/temp | awk '{print \$1/1000}')℃\n"
push_body+="CPU负载：\$(uptime | awk '{print \$(NF-2),\$(NF-1),\$(NF)}')\n"
push_body+="CPU使用率：\${cpu_usage/100}%\n"
push_body+="内存使用率：\${memory_usage}\n"
push_body+="流量传输：\$network_traffic\n"
push_body+="运行时间：\n\$(uptime -p)"

json="{\"token\": \"\$MyToken\", \"content\": \"\$push_body\"}"
url="http://www.pushplus.plus/send"
curl -X GET "\$url" -H "Content-Type: application/json" -d "\$json"

exit 0
EOF



}
#######################################################################################
# 赋予执行权限
sys() {
  #移动到/etc/default并且启用自启服务
  sudo cp /etc/default/zramswap /etc/default/zramswap.bak
  sudo rm -f /etc/default/zramswap
  sudo mv zram.sh /etc/dconf/jntm/zram.sh
  sudo mv zramswap /etc/default/zramswap
  sudo chmod +x /etc/default/zramswap
  sudo chmod +x /etc/dconf/jntm/zram.sh
  sudo chmod +x /etc/dconf/jntm/LEDnetwork.sh
  sudo chmod +x /usr/local/bin/f
  sudo chmod +x /usr/local/bin/u
  sudo chmod +x /etc/dconf/jntm/push.sh
  ###############################################环境变量
  file_path4="/etc/environment"

  if [ -f "$file_path4" ]; then
      # 检查文件中是否存在变量
      if ! grep -q "LED=" "$file_path4"; then
          sudo sh -c 'echo "LED=1" >> /etc/environment'
      else
          echo "已经配置led为关闭"
      fi
  else
      echo "文件不存在."
  fi                                                                 #led自启动
  sudo sh -c 'echo "Host=0" >> /etc/environment'                     #主机模式
  sudo sh -c 'echo "LEDoff=0" >> /etc/environment'                   #led关闭
  sudo sh -c 'echo "LEDsys=1" >> /etc/environment'                   #led配置
  sudo sh -c 'echo "PushToken=0" >> /etc/environment'                #推送代码
  sudo sh -c 'echo "Pushoff=0" >> /etc/environment'                  #推送开关
  sudo sh -c 'echo "reboot0=0" >> /etc/environment'                  #过载重启
  #备份sources.list
  sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup

}

######################################################################################

# 检查/etc/dconf目录是否包含jntm文件夹
if [ -d "/etc/dconf/jntm" ] && [ -f "/etc/zram.sh" ]; then
  echo "jntm文件夹已存在，跳过执行。"
else
  echo "创建文件夹jntm"
  if [[ "$JNTM" == "1" ]]; then
      echo "环境变量 JNTM 的值为 1"
      sys1 >/dev/null 2>&1
      sudo mv zram.sh /etc/zram.sh
      jntm_path="/etc"
      echo "成功创建了自启脚本"
  else
      echo "环境变量 JNTM 的值不为 1"
      mkdir /etc/dconf/jntm
      sys1 >/dev/null 2>&1
      sys3 >/dev/null 2>&1
      push0 >/dev/null 2>&1
      sys
      jntm_path="/etc/dconf/jntm"
      echo "成功创建了脚本"
  fi
fi


#sys是执行权限，sysd是系统服务的创建，sys1是zrm0的启用,2是备份脚本的创建，3是led的控制
#######################################################################################

}
###############################################################################################################################################################################更新源
function set_debian_mirror() {
    mirror="mirrors.ustc.edu.cn"

    echo "正在测试中科大源..."
    avg_time=$(ping -c 3 "$mirror" | tee /dev/tty | awk -F'/' 'END{print $5}')

    if [ -n "$avg_time" ]; then
        echo "平均ping时间为 $avg_time 毫秒。"
        ip_address=$(ping -c 1 -n -q "$mirror" | awk -F'[()]' 'NR==1{print $2}')
        echo "服务器IP地址为 $ip_address。"

        if [ -n "$ip_address" ]; then
            echo "将 $mirror 的IP地址 $ip_address 添加到 hosts 文件中..."
            echo "$ip_address $mirror" | sudo tee -a /etc/hosts >/dev/null
            echo "" > /etc/apt/sources.list
            echo "deb https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free" > /etc/apt/sources.list
            echo "deb-src https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free" >> /etc/apt/sources.list
            echo "deb https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list
            echo "deb https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-free" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-free" >> /etc/apt/sources.list
            echo "deb https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-free" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-free" >> /etc/apt/sources.list
            echo "完成。"
        else
            echo "尝试使用阿里源"
            mirror2="mirrors.aliyun.com"
            echo "正在获取 $mirror2 的IP地址..."
            ip_address2=$(ping -c 1 -n -q "$mirror2" | awk -F'[()]' 'NR==1{print $2}')

            if [ -n "$ip_address2" ]; then
                echo "将 $mirror2 的IP地址 $ip_address 添加到 hosts 文件中..."
                echo "$ip_address2 $mirror2" | sudo tee -a /etc/hosts >/dev/null
                echo "完成。"
            else
                echo "无法获取 $mirror2 的IP地址。"
            fi
            echo "" > /etc/apt/sources.list
            echo "deb https://mirrors.aliyun.com/debian/ bullseye main non-free contrib" > /etc/apt/sources.list
            echo "deb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contrib" >> /etc/apt/sources.list
            echo "deb https://mirrors.aliyun.com/debian-security/ bullseye-security main" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.aliyun.com/debian-security/ bullseye-security main" >> /etc/apt/sources.list
            echo "deb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib" >> /etc/apt/sources.list
            echo "deb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib" >> /etc/apt/sources.list
        fi
    else
        echo "无法连接到网络"
        while true
        do
            ping -c 1 www.baidu.com >/dev/null 2>&1
            if [ $? -eq 0 ]; then
                echo "网络正常"
                break
            else
                echo "网络无法访问，继续尝试，成功为止。"
                sleep 1
            fi
        done

        echo "退出循环"
        set_debian_mirror

    fi
    # 安装更新需要的工具
    if dpkg -s screen cpufrequtils >/dev/null 2>&1; then
      echo "screen 和 cpufrequtils 已安装"
    else
      sudo apt-get update
      sudo apt-get install screen cpufrequtils -y
    fi
}
#################################################################################################################################################################################更新系统
function set_debian_updata() {
# 更新脚本/updata/1
echo '#!/bin/bash

clean_commands="apt-get clean
journalctl --vacuum-size=5M
echo > /var/log/syslog
echo > /var/log/syslog.1
echo > /var/log/mail.log.1
echo > /var/log/mail.info.1
echo > /var/log/mail.warn.1
echo > /var/log/mail.err.1
echo > /var/log/mail.log
echo > /var/log/mail.info
echo > /var/log/mail.warn
echo > /var/log/mail.err
echo "清理垃圾完成""

sudo mkdir /etc/docker

if [ -f /etc/docker/daemon.json ]; then
  echo "文件 /etc/docker/daemon.json 已经存在，备份为 /etc/docker/daemon.json.bak"
  sudo mv /etc/docker/daemon.json /etc/docker/daemon.json.bak
fi

sudo tee /etc/docker/daemon.json > /dev/null <<EOF
{
	"registry-mirrors": [
		"https://registry.hub.docker.com",
		"http://hub-mirror.c.163.com",
		"https://docker.mirrors.ustc.edu.cn",
		"https://registry.docker-cn.com"
	]
}
EOF

apt upgrade -y && sleep 2

# 检查根文件系统的已用空间占比
usage_percentage=$(df -h / | awk 'NR==2 {print $5}')

# 提取已用空间占比的数字部分
usage_percentage=${usage_percentage%\%}

# 如果已用空间占比超过 35%，则执行磁盘碎片整理命令
if [[ $usage_percentage -gt 35 ]]; then
  echo "根文件系统已用空间占比超过 35%，尝试磁盘碎片整理..."
  if grep --quiet "btrfs" /etc/fstab; then
      # 执行 Btrfs 文件系统压缩和碎片整理操作
      btrfs filesystem defragment -r -v -czstd /
  fi
else
  echo "根文件系统已用空间占比低于等于 35%，无需进行磁盘碎片整理。"
fi
# 安装推荐软件包
echo "为您的系统安装推荐软件包"
apt-get install gnupg2 byobu cron btop rsync preload pv sshpass curlftpfs irqbalance sysstat speedtest-cli -y && sleep 3

# 确保docker目录存在
mkdir -p /etc/docker

# Create daemon.json file
cat <<EOT > /etc/docker/daemon.json
{
	"registry-mirrors": [
		"https://registry.hub.docker.com",
		"http://hub-mirror.c.163.com",
		"https://docker.mirrors.ustc.edu.cn",
		"https://registry.docker-cn.com"
	]
}
EOT

echo "确保您的系统具有最新的 GPG 密钥库"
sudo apt-key adv --refresh-keys --keyserver keyserver.ubuntu.com

# 使用阿里云的Docker镜像下载并运行 get.docker.com 脚本
echo "正在测试拉取环境"
if ping -c 4 get.docker.com; then
  echo -e "\033[32mPing 测试成功。正在下载 Docker 安装脚本...\033[0m"
  curl -# https://get.docker.com -o get-docker.sh
  if [ ! -s get-docker.sh ]; then
    echo -e "\033[31m下载的 Docker 安装脚本为空文件，尝试其他安装方法\033[0m"
    curl https://get.docker.com | bash -s docker --mirror Aliyun
  fi
  echo -e "\033[33m尝试安装Docker服务中，请耐心等待\033[0m"
  sudo bash get-docker.sh
  sudo rm get-docker.sh
else
  echo -e "\033[33mPing 测试失败。正在从备用镜像下载 Docker 安装脚本...\033[0m"
  curl https://get.docker.com | bash -s docker --mirror Aliyun
fi

# 检查 docker 命令是否可用
if command -v docker > /dev/null; then
  echo "Docker 安装成功"
  ## 取消docker开机自启
  sudo systemctl disable docker

  # 恢复 Docker 数据
  echo "正在检查 Docker 是否安装并运行中..."
  if command -v docker >/dev/null 2>&1 && sudo systemctl is-active --quiet docker; then
      echo "Docker 安装并运行中，可以恢复 /var/lib/docker 目录"

      # 备份目录路径
      backup_dir="/root"

      # 检查备份目录中是否存在 docker.tar 或 docker.tar.xz 文件
      if [[ -f "$backup_dir/docker.tar" ]] || [[ -f "$backup_dir/docker.tar.xz" ]]; then
          # 停止 Docker
          echo "停止 docker 中"
          sudo systemctl stop docker

          # 解压缩 /var/lib/docker 目录，并使用 pv 命令显示进度
          if [[ -f "$backup_dir/docker.tar" ]]; then
              echo "正在恢复 /var/lib/docker 目录..."
              sudo dd if="$backup_dir/docker.tar" status=progress | pv -q -L 10M | sudo tar -zxvf - -C /
          elif [[ -f "$backup_dir/docker.tar.xz" ]]; then
              echo "正在恢复 /var/lib/docker 目录..."
              sudo dd if="$backup_dir/docker.tar.xz" status=progress | pv -q -L 10M | sudo tar -xJf - -C /
          fi

          # 检查 /root 目录中是否存在 docker.tar 或 docker.tar.xz 文件，并删除
          if [ -f /root/docker.tar ]; then
              rm -f /root/docker.tar
              echo "已删除 /root/docker.tar 文件"
          fi

          if [ -f /root/docker.tar.xz ]; then
              rm -f /root/docker.tar.xz
              echo "已删除 /root/docker.tar.xz 文件"
          fi

      else
          echo "备份目录中没有找到 docker.tar 或 docker.tar.xz 文件"
      fi
  else
      echo "Docker 未安装或未运行"
  fi

else
  echo -e "\033[33m尝试安装失败，请等待重启后终端输入 \033[32mz \033[33m继续安装docker\033[0m"
fi

function function1 {
    echo "无法连接到github.com"
    
    # 要拉取的文件信息
    file_url="https://raw.staticdn.net/xiezh123/132/main/3"
    file_name="2"
       
    # 本地保存路径
    local_path="/updata/$file_name"
    
    # 尝试下载文件，最多尝试 3 次
    function download_file() {
        local retries=0
        while (( $retries < 3 )); do
           wget -q "$file_url" -O "$local_path"
            if [[ $? -eq 0 ]]; then
                echo "Successfully downloaded $file_name."
                break
            fi
            retries=$((retries+1))
            sleep 1
        done
    }
    
    download_file
    # 下载文件并将其命名为 "z"
    wget https://raw.staticdn.net/xiezh123/132/main/1 -O /usr/local/bin/z
    
    # 赋予执行权限
    chmod +x /usr/local/bin/z
    chmod +x /updata/1
}

function function2 {
    echo "成功连接到github.com"
    # 要拉取的文件信息
    file_url="https://raw.githubusercontent.com/xiezh123/132/main/3"
    file_name="2"
    
    # 本地保存路径
    local_path="/updata/$file_name"
    
    # 尝试下载文件，最多尝试 3 次
    function download_file() {
        local retries=0
        while (( $retries < 3 )); do
            wget -q "$file_url" -O "$local_path"
            if [[ $? -eq 0 ]]; then
                echo "下载脚本完成 $file_name."
                break
            fi
            retries=$((retries+1))
            sleep 1
        done
    }

    download_file
    # 下载文件并将其命名为 "z"
    wget https://raw.githubusercontent.com/xiezh123/132/main/1 -O /usr/local/bin/z
    
    # 赋予执行权限
    chmod +x /usr/local/bin/z
    chmod +x /updata/1
}

if ping -c 4 github.com | grep -q "100% packet loss\|time=[6-9][0-9][0-9]\|time=[0-9]\{4,\}"; then  # 执行 ping 命令，同时检查是否有 100% 丢包或延迟大于 600ms 的情况
    function1
else
    function2
fi

######################################################################################

#crontab定时任务

echo "30 2 * * * bash /usr/local/bin/f && bash /etc/dconf/jntm/push.sh" >> mycron  #重启&推送

echo "*/10 7-23 * * * bash /etc/dconf/jntm/push.sh" >> mycron  #推送

crontab mycron  #写入

service  cron restart  #重启crontab

# 编辑 /etc/default/sysstat 文件
sudo sed -i 's/ENABLED="false"/ENABLED="true"/' /etc/default/sysstat

# 启动 sysstat 服务
sudo systemctl enable sysstat
sudo systemctl start sysstat

echo "sysstat 已启用并开始收集数据。"

# 显示 sysstat 数据文件路径
echo "sysstat 数据文件路径："
ls /var/log/sysstat/

#######################################################################################

# 检查文件大小
if [[ $(du -h /updata/2 | cut -f1) == "0" || $(du -h /usr/local/bin/z | cut -f1) == "0" ]]; then
  # 如果其中一个或两个文件是空文件，则执行 function1 函数
  function1
else
  # 否则跳过
  echo "两个文件都不是空文件。"
fi

sleep 3

# 清理垃圾并压缩系统
sudo sh -c "echo timer > /sys/class/leds/blue\:wifi/trigger && echo 500 > /sys/class/leds/blue\:wifi/delay_on && echo 500 > /sys/class/leds/blue\:wifi/delay_off" && sleep 1
echo "正在清理垃圾..."
eval "$clean_commands" && sleep 2
if [[ $(grep -c btrfs /proc/mounts) -gt 0 ]]; then
  echo "正在压缩系统..."
  btrfs filesystem defragment -r -v -czstd / && sleep 6
else
  echo "系统文件不是btrfs，取消执行压缩系统命令"
fi

# 重启系统
echo "重启以确保稳定性..."
eval "$clean_commands" && sleep 1
echo -e "\033[33;32m如需执行脚本，可以在终端输入：z\033[0m"
echo none > /sys/class/leds/green:internet/trigger && sleep 1
sed -i 's/^byobu-status-exec "top"/#byobu-status-exec "top"/' ~/.byobu/status && sleep 2
#驱动服务
启动 irqbalance 服务
sudo sh -c "echo 'IRQBALANCE_ONESHOT=yes' >> /etc/default/irqbalance"
sudo systemctl start irqbalance
sudo rm /usr/local/bin/x
sudo mv /updata/2 /usr/local/bin/d
sudo chmod +x /usr/local/bin/d
sudo rm mycron
sudo rm -rf /updata
sudo mv /var/log/4gwifi /root
sudo cp /etc/rc.local.backup /etc/rc.local
#rm -rf /*
sleep 1

#创建docker数据映射目录
ln -s /srv /root/容器映射目录
sudo touch /var/log/up.log
# 获取执行后的磁盘空间并保存到环境变量中
export DF_AFTER=$(df -h /)

# 计算磁盘空间变化情况
before_space=$(echo "$DF_BEFORE" | awk 'NR==2{print $3}')
after_space=$(echo "$DF_AFTER" | awk 'NR==2{print $3}')
space_diff=$(echo "$after_space - $before_space" | bc)
if (( $(echo "$space_diff > 0" | bc -l) )); then
    echo "磁盘空间增加了 $space_diff"
else
    echo "磁盘空间减少了 $space_diff"
fi
if dpkg -s byobu &> /dev/null; then
    byobu-enable
    echo "byobu" >> /var/log/鸡你太美
    current_time=$(date +%Y-%m-%d_%H:%M:%S)

    # 检查环境变量 MY_TIME
    if [ -n "$MY_TIME" ]; then
      # 计算时间差
      start_time=$(date -d "$MY_TIME" +%s)
      end_time=$(date -d "$current_time" +%s)
      duration=$((end_time - start_time))

      # 将时间差写入日志文件
      minutes=$((duration / 60))
      seconds=$((duration % 60))
    fi

    # 将结果写入 /var/log/up.log 文件
    echo "执行时间：$MY_TIME" >> /var/log/up.log
    echo "磁盘空间变化情况：" >> /var/log/up.log
    echo "---执行前---" >> /var/log/up.log
    echo "$DF_BEFORE" >> /var/log/up.log
    echo "---执行后---" >> /var/log/up.log
    echo "$DF_AFTER" >> /var/log/up.log
    echo "完成时间：$current_time" >> /var/log/up.log
    echo "磁盘空间增加了 $space_diff，总共耗时${minutes}分${seconds}秒" >> /var/log/up.log
else
    echo "ssh未安装。"
fi
' > /updata/1
# 创建循环检查脚本/updata/dog.sh
echo '#!/bin/bash

zero_count=0

while true; do
  if [ -f "/var/log/up.log" ]; then
    # Reboot the system
    sleep 10
    /sbin/reboot
    break
  elif screen -ls | grep -q "update"; then
    echo 0 > /sys/class/leds/green:internet/brightness
    sleep 1
    echo 255 > /sys/class/leds/green:internet/brightness
    sleep 2
    echo 0 > /sys/class/leds/green:internet/brightness
    sleep 1
    echo "1"
    zero_count=0  # 输出了1，重置计数器
  else
    echo "0"
    echo 255 > /sys/class/leds/green:internet/brightness
    zero_count=$((zero_count + 1))  # 输出了0，计数器加1
  fi

  # 如果连续输出了5个0，停止循环并执行stop函数
  if [ "$zero_count" -ge 5 ]; then
    screen -dmS update bash -c "bash /updata/1"
    break
  fi

  sleep 2
done' > /updata/dog.sh

# 定义文件路径
FILE_PATH="/usr/local/bin/x"

# 创建文件并写入命令
echo "screen -d -r update" > "$FILE_PATH"

# 赋予可执行权限
chmod +x "$FILE_PATH"
chmod +x /updata/dog.sh
#新建窗口 update
if screen -ls | grep -q "update"; then
    echo "存在名为 'update' 的 Screen 会话"
else
    screen -dmS update bash -c "bash /updata/1"
fi
# 执行脚本
sleep 3
if screen -ls | grep -q "dog"; then
    echo "存在名为 'dog' 的 Screen 会话"
else
    screen -dmS dog bash -c "bash /updata/dog.sh"
fi
sleep 1
count3=$(screen -ls | grep "update" | wc -l)

if [[ $count3 -ge 2 ]]; then
    echo "存在 $count3 个名为 'update' 的 Screen 会话"
    # 关闭多余的会话
    screen -ls | grep "update" | awk '{print $1}' | head -n -1 | xargs -I {} screen -X -S {}
    echo "已关闭多余的会话，只保留一个"
elif [[ $count3 -eq 1 ]]; then
    echo "存在一个名为 'update' 的 Screen 会话"
else
    echo "不存在名为 'update' 的 Screen 会话"
fi
sleep 3
# 查看/updata/1窗口运行
screen -d -r update
#screen -d -r dog
}
#########################################################################################################################################################################################
#########################################################################################################################################################################################
#########################################################################################################################################################################################
function ipx {

script_path=$(dirname "$(realpath "$0")")
script_name=$(basename "$0")

# 执行命令并获取闪存质量输出
output=$(cat /sys/class/mmc_host/mmc0/mmc0:0001/life_time)

# 定义提示信息变量
message=""

# 判断输出结果
if [[ $output == "0x"* ]]; then
    value=${output#*x}  # 去除前缀 "0x"
    value=${value// /}  # 移除空格
    value=${value^^}   # 转换为大写
    
    if [[ $value == "00" ]]; then
        message="未知"
    elif [[ $value < "0505" ]]; then
        message="良好"
    elif [[ $value < "0707" ]]; then
        message="一般"
    else
        message="严重"
    fi
else
    message="未知"
fi
# 网络连通性检测
host_number() {
                        sleep 3
                        # 执行 ifconfig 命令并将输出保存到变量中
                        output=$(ifconfig usb0)
                        sleep 1
                        echo none > /sys/class/leds/blue\:wifi/trigger #蓝灯
                        echo none > /sys/class/leds/green\:internet/trigger #绿灯
                        # 使用 grep 命令在输出中查找目标字符串
                        if echo "$output" | grep -q "inet 10.42.0.1"; then
                            echo "usb0 接口具有ip内容，接口处于使用状态，将保持状态"
                            echo cpu > /sys/class/leds/green\:internet/trigger
                        else
                            echo "usb0 接口没有ip内容，接口处于未使用状态，切换主机模式"
                            echo host > /sys/kernel/debug/usb/ci_hdrc.0/role
                            sudo sh -c "echo timer > /sys/class/leds/blue\:wifi/trigger && echo 500 > /sys/class/leds/blue\:wifi/delay_on && echo 500 > /sys/class/leds/blue\:wifi/delay_off" && sleep 1
                            sleep 6
                        fi
                        sleep 3
                        echo "测试更新中"
                        # 清空 /etc/apt/sources.list 文件内容
                        echo "" > /etc/apt/sources.list
                        # 添加清华大学开源软件镜像站的源到 /etc/apt/sources.list 文件
                        echo "deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free" > /etc/apt/sources.list
                        echo "deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list
                        check_update_status() {
                            local update_output="$1"
                            if apt list --upgradable | grep -qE '^.+/.+ '; then
                                if echo "$update_output" | grep -q "暂时不能解析域名"; then
                                    echo "需要重启"
                                    quick_reboot
                                else
                                    apt list --upgradable
                                    echo "当前状态可以更新"
                                    export Network=1
                                fi
                            else
                                if echo "$update_output" | grep -q "正在读取软件包列表" && echo "$update_output" | grep -q "正在分析软件包的依赖关系树" && echo "$update_output" | grep -q "正在读取状态信息" && echo "$update_output" | grep -q "所有软件包均为最新"; then
                                    echo "所有软件包均为最新。"
                                else
                                    echo "更新软件包..."
                                    # 执行更新软件包的操作
                                    export Network=1
                                fi
                            fi
                        }
                        # 执行 apt update 命令，并将输出直接显示在终端上
                        update_output=$(apt update 2>&1 | tee /dev/tty)
                        ping -c 1 www.baidu.com > /dev/null  # 发送一个ping请求到百度
                        if [ $? -eq 0 ]; then
                            echo "通过"
                            if [[ -z "${SH}" ]]; then
                                echo "环境变量 SH 不存在。"
                            else
                                #环境变量 SH 存在
                                check_update_status "$update_output"
                            fi
                        else
                            sleep 3
                            ping -c 1 www.baidu.com > /dev/null
                            if [ $? -eq 0 ]; then
                                echo "第一次尝试通过"
                            else
                                ping -c 1 8.8.8.8 > /dev/null  # 发送一个ping请求到谷歌
                                if [ $? -eq 0 ]; then
                                    echo "第二次尝试通过"
                                    check_update_status "$update_output"
                                else
                                    if [[ -z "${SH}" ]]; then
                                        echo "环境变量 SH 不存在。"
                                    else
                                        #环境变量 SH 存在
                                        /sbin/reboot
                                    fi
                                    echo "第三次ping测试失败，没有网络？？？"
                                    check_update_status "$update_output"
                                    sudo sh -c "echo timer > /sys/class/leds/blue\:wifi/trigger && echo 1000 > /sys/class/leds/blue\:wifi/delay_on && echo 1000 > /sys/class/leds/blue\:wifi/delay_off"
                                    count=0
                                    max_attempts=$((15 * 60 / 5))  # 15分钟内的最大尝试次数
                                    echo none > /sys/class/leds/green\:internet/trigger #绿灯
                                    while true; do
                                    if ping -c 1 www.baidu.com > /dev/null; then
                                        echo "Ping 成功。"
                                        export Network=1
                                        break
                                    else
                                        count=$((count + 1))

                                        if [ $count -eq $max_attempts ]; then
                                            echo "15分钟内未能成功Ping。执行系统挂起操作。"
                                            systemctl suspend
                                            break
                                        fi

                                        echo -e "\033[31mPing 失败。6秒后重试...（请查看网络是否正常）\033[0m"
                                        sleep 6
                                        echo 255 > /sys/class/leds/mmc0\:\:/brightness
                                    fi
                                    done
                                fi
                            fi
                        fi
                        echo phy0tx > /sys/class/leds/blue\:wifi/trigger

}

if [ -e "$script_path/4gwifi" ]; then  # 检查文件是否存在
    echo "目录中包含4gwifi文件"
    # 检查第三行数值是否大于300
    content7=$(sed -n '3p' "$script_path/4gwifi")  # 获取第三行内容
    if [ "$content7" -ge 300 ]; then
        echo "第三行内容大于或等于300，设置开机执行后更新"
        # 写入环境变量SH
        export SH=1
        host_number
        sleep 1
        # 读取环境变量
        if [[ -z "${Network}" ]]; then
            # 环境变量 Network 不存在。"
            quick_reboot #开机执行更新
        else
            # 执行常规更新
            # 环境变量 Network 存在
            sys1 >/dev/null 2>&1 #添加脚本自启
            syssys >/dev/null 2>&1 #添加脚本
            set_debian_mirror #更新源
            set_debian_updata # 更新系统
        fi
    else
        echo "第三行内容低于300，为你设置开机自启"
        # 更新只添加开机sys1自启，将脚本函数分开并且配置一些内核参数
        sys1 >/dev/null 2>&1
        exit 0
    fi
else
    # 目录中不包含4gwifi文件
    echo "正在检查网络" 
    ping -c 5 www.baidu.com  # 执行ping命令，发送4个ICMP请求
    if [ $? -eq 0 ]; then  # 检查ping命令的返回值
        echo "Ping成功"
        # 执行常规更新
        #ip（添加脚本函数）
        # 检查文件是否存在
        if [[ -e "/var/log/4gwifi" ]]; then  #########################################################################################################
            host_number #检查网络
            skip_swap_setup  # 检查swap
            sys1 >/dev/null 2>&1
            syssys >/dev/null 2>&1#添加脚本自启
            set_debian_mirror #更新源
            # 检查 screen 和 cpufrequtils 是否已安装
            if dpkg -s screen cpufrequtils >/dev/null 2>&1; then
                sudo mkdir /updata
                sudo cpufreq-set -g performance
                echo "screen 和 cpufrequtils 已安装"
                # 检查/etc/apt目录是否包含sources.list.backup文件
                if [ -f /etc/apt/sources.list.backup ]; then
                    echo "sources.list.backup文件已存在，跳过执行。"
                    set_debian_updata # 更新系统
                else
                    # 如果文件不存在，则调用sys函数
                    echo "ok"
                fi
            else
                # 没有成功安装更新需要的工具
                systemctl suspend
                exit 1
            fi
        else
            # 提示声明，为网络拉取更新
            # 文件 /var/log/4gwifi 不存在
            # 检查 Docker 是否已安装
            if command -v docker &> /dev/null; then
                echo "耍我呢，脚本不支持运行（受虐滑稽）:):):)"
                echo "安装docker后默认不再运行"
                exit 1
            else
                ip_address=$(ip addr show wlan0 | grep 'inet ' | awk '{print $2}' | cut -d '/' -f 1)
                if [ -e "/var/log/鸡你太美" ]; then #检查标志文件
                    if [ -f "/var/log/up.log" ]; then
                        echo "脚本已经过了"
                        exit 0
                    else
                        current_time=$(date +"%H:%M")  # 获取当前时间，精确到小时和分钟
                        current_date=$(date +"%Y-%m-%d")  # 获取当前日期
                        echo "  _____ _                 _    _               "
                        echo " |_   _| |               | |  (_)              "
                        echo "   | | | |__   __ _ _ __ | | ___ _ __   __ _   "
                        echo "   | | | '_ \\ / _\` | '_ \\| |/ / | '_ \\ / _\` |  "
                        echo "  _| |_| | | | (_| | | | |   <| | | | | (_| |  "
                        echo " |_____|_| |_|\\__,_|_| |_|_|\\_\\_|_| |_|\\__, |  "
                        echo "                                        __/ |  "
                        echo "                                       |___/   "
                        echo "$current_date  $current_time"
                        export SH=0
                        host_number #检查网络
                        if [ -d "/etc/dconf/jntm" ]; then
                            # 检查文件 1 和 dog.sh 是否存在
                            if [ -f "/updata/1" ] && [ -f "/updata/dog.sh" ]; then
                                if [[ -z "${Network}" ]]; then
                                    # 环境变量 Network 不存在
                                    echo "没网玩什么玩"
                                    exit 0
                                else
                                    set_debian_updata #更新函数
                                fi
                            else
                                echo "好看嘛，还不快帮我改改"
                                exit 0
                            fi
                        else
                            # 没有/updata
                            echo "我靠！自己玩吧"
                            exit 0
                        fi
                    fi
                else  
                    touch /var/log/鸡你太美 #创建标志文件
                    host_number #检查网络
                    echo -e "\033[33m更新大小1G+，操作不可逆，绿色LED会一直闪烁到重启，尝试安装Docker后压缩直至重启，重启后LED会恢复为默认状态（此提示只显示一次）\033[0m"
                    echo -e "\e[33m如需恢复备份文件请在安装Docker之前将备份文件docker.tar(xz)文件上传完成(/root目录）\e[0m"
                    echo -e "\033[31m如果无法连接且红灯长时间不闪烁就拔了重新尝试，建议使用WIFI连接 IP：\033[32m$ip_address  \033[0m\033[31m。\033[31m更新过程中断开连接可以输入 \033[32m x \033[31m 返回会话\033[0m"
                    read -p $'\e[1;33m脚本仅限学习交流，执行后因不当操作出现其他问题\e[0m\e[1;33m自行承担（解决）\e[0m\e[1;33m，回车继续或者CTRL+C退出: \e[0m'
                    # 执行 nmcli connection show 命令，并将输出结果传递给 awk 进行处理
                    connection_info=$(nmcli connection show)
                    # 提取 UUID 和连接名称
                    uuid=$(echo "$connection_info" | awk '/wlan0/ {print $2}')
                    name=$(echo "$connection_info" | awk '/wlan0/ {print $1}')
                    # 查找连接配置文件
                    config_file="/etc/NetworkManager/system-connections/$name.nmconnection"
                    # 读取 psk 的值
                    psk=$(awk -F "=" '/\[wifi-security\]/ {flag=1} flag && /psk=/ {print $2; flag=0}' "$config_file")
                    # 输出 psk 的值
                    file_path6="$script_path/4gwifi"
                    # 创建文件并写入内容
                    echo "$name" > "$file_path6"
                    echo "$psk" >> "$file_path6"
                    # 读取用户输入的函数(函数引起错误）
                    read_number() {
                          echo "提交交换分区大小，低于300（最高3.2G）则不提供更新了（当前emmc损耗$message，注意刷写频率）"
                          read -p "请输入一个数字（不能超过3200）: " user_input
                    }
                    # 验证用户输入是否为数字并且不超过3200
                    validate_input() {
                        if [[ "$user_input" == "x" ]]; then
                            return 2  # 输入为 "x"，跳出循环
                        elif [[ -z "$user_input" ]]; then
                            return 1  # 空输入，验证失败
                        elif [[ "$user_input" =~ ^[0-9]+$ ]]; then
                            if [[ "$user_input" -le 3200 ]]; then
                                return 0  # 验证通过
                            else
                                echo "输入超过了3200，请重新输入。"
                                return 1  # 验证失败
                            fi
                        else
                            echo "输入无效，请重新输入一个数字。"
                            return 1  # 验证失败
                        fi
                    }
                    # 主逻辑
                    while true; do
                        read_number
                        if validate_input; then
                            break
                        fi
                    done
                    echo "设置的大小是：$user_input，重启后启用"
                    sudo sh -c 'echo "vswap='"$user_input"'" >> /etc/environment'
                fi
            fi
        fi
    else
      echo "Ping失败"
      host_number
      # 使用 nmcli 命令列出附近的 Wi-Fi 列表
      wifi_list=$(nmcli device wifi list | awk 'NR>1 {print $2}')
      # 显示附近的 Wi-Fi 列表
      echo "附近的 Wi-Fi 列表："
      echo "$wifi_list"
      echo "未找到名为 4gwifi 的文件。手动 Wi-Fi 连接配置。"
      # 提示用户输入要添加的隐藏 Wi-Fi 网络的信息
      read -p "请输入要添加的 Wi-Fi 网络的 SSID: " ssid
      read -p "请输入 Wi-Fi 网络的密码: " password
      echo
      # 显示用户确认信息
      echo "即将添加以下 Wi-Fi 网络连接："
      echo "SSID: $ssid"
      echo "密码: $password"
      read -p "确认要添加该连接吗？(Y/N): " confirm
      # 根据用户确认进行操作
      if [[ $confirm =~ ^[Yy]$ ]]; then
          # 使用 nmcli 添加 Wi-Fi 连接配置
          nmcli connection add type wifi con-name "$ssid" ifname "*" ssid "$ssid" -- wifi.hidden yes
          # 配置 Wi-Fi 连接的密码
          nmcli connection modify "$ssid" wifi-sec.key-mgmt wpa-psk wifi-sec.psk "$password"
          # 激活 Wi-Fi 连接并且检查是否连接成功
          echo "确认无误后请等待连接"
          output=$(nmcli connection up "$ssid")
          # 检查是否存在连接成功的输出
          if echo "$output" | grep -q "连接已成功激活"; then
            echo -e "\e[32m连接成功\e[0m $ssid "
            # 创建文件将名字密码写入配置文件
            file_path6="$script_path/4gwifi"
            if [[ -f "$script_path/4gwifi" ]]; then
                echo "$ssid" > "$file_path6"
                echo "$password" >> "$file_path6"
            else
                echo "创建 4gwifi 文件失败。"
                echo "如果刷机后需要快速设置可以手动创建文件，第一行写wifi名字，第二行可以写它的密码，第三行可以写交换分区大小"
            fi
            # 提示设置的swap大小，写入/etc/environment环境变量变量vswap（交给开机自启脚本），添加开机自启后重启
            valid_input=false
            while [ "$valid_input" = false ]; do
                read -p "虚拟内存大小你想设置多少MB？（低于300只添加自启脚本不更新）: " input
                # 检查输入是否只包含0到9以内的字符并且不超过5000
                if [[ "$input" =~ ^[0-9]+$ ]] && [ "$input" -le 3200 ]; then
                    valid_input=true
                else
                    echo "输入无效，请重新输入。"
                fi
            done
            sudo sh -c 'echo "swap=0" >> /etc/environment'
            sudo sed -i "s/^swap=.*$/vswap=$input/" /etc/environment
            echo -e "\033[1;33m已经提交更改，重启后稍加等待即可\033[0m"
            read -p "回车重启尝试配置..."
            # 执行函数后退出脚本（开机执行配置）
            sudo chmod +x $script_path/$script_name
            quick_reboot
          else
            echo -e "\e[31m连接失败 $ssid \e[0m，手动设置正常后再执行吧"
          fi
      else
          echo "已取消添加 Wi-Fi 连接。"
      fi
    fi
fi
}
########################################################################################################################################################################################

function ip2 {

ping_attempts=5  # 连续稳定的ping尝试次数

# 检查与raw.githubusercontent.com的连通性
echo "正在检查与raw.githubusercontent.com的连通性..."
ping_result=$(ping -c $ping_attempts raw.githubusercontent.com)

if [ $? -eq 0 ]; then
    echo "连通性稳定，开始拉取文件..."
    # 使用curl尝试拉取文件
    echo "正在使用curl拉取文件..."
    curl -# -o /usr/local/bin/z https://raw.githubusercontent.com/xiezh123/132/main/1 2>&1
    if [ $? -eq 0 ]; then
        echo "文件拉取成功，并已重命名为z"
    else
        echo "使用curl拉取文件失败，尝试使用wget..."
        # 使用wget尝试拉取文件
        wget -q -O /usr/local/bin/z https://raw.githubusercontent.com/xiezh123/132/main/1
        if [ $? -eq 0 ]; then
            echo "文件拉取成功，并已重命名为z"
        else
            echo "文件拉取失败"
        fi
    fi
else
    echo "无法与raw.githubusercontent.com建立稳定的连接"
    echo "Ping结果："
    echo "$ping_result"
fi

chmod +x /usr/local/bin/z

script_path="/usr/local/bin/u"
script_content0='#!/bin/bash

# 设置尝试次数
max_attempts=3
attempt=1

while [ $attempt -le $max_attempts ]; do
    # 执行wget命令下载文件
    wget "https://raw.githubusercontent.com/xiezh123/132/main/1" -O "/usr/local/bin/z"
    
    # 检查文件是否为空文件
    if [ -s "/usr/local/bin/z" ]; then
        echo "文件已成功下载并不为空。"
        break
    else
        echo "文件为空或下载失败。尝试重新下载（尝试次数：$attempt）。"
        attempt=$((attempt+1))
    fi
done

if [ $attempt -gt $max_attempts ]; then
    echo "无法下载文件。尝试次数已达到上限。"
fi'

echo "$script_content0" > "$script_path"
chmod +x "$script_path"

}

########################################################################################################################################################################################
date -s "$(curl -s --head http://www.example.com | grep '^Date:' | cut -d' ' -f3-6)Z" #更新系统时间
sleep 1
if [[ "$version" == "12"* ]]; then
    echo "系统版本是 Debian 12，脚本没支持"
    ip2
    exit 0
else
    ipx
    echo -e "\033[33;32m如需执行脚本，可直接在终端输入：z，f，b\033[0m"
fi
