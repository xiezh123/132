#!/bin/bash

############################################################################################

if ! ls /boot/vmlinuz-5.15.0-jsbsbxjxh66+ &> /dev/null && ! ls /boot/vmlinuz-6.4.0-rc4-jsbsbxjxh66-compile+ &> /dev/null ; then
    echo "脚本无法在此设备上运行"
    sudo rm /root/0
    exit 1
fi

function ip1 {

# 获取执行前的磁盘空间并保存到环境变量中
export DF_BEFORE=$(df -h /)

# 获取当前时间并保存到环境变量中
export MY_TIME=$(date +%Y-%m-%d_%H:%M:%S)
################################################################################################################################################################################设置sawp

function skip_swap_setup {
  
  # 要添加到 hosts 文件中的 IP 地址和域名
  ip_list="157.148.69.80 www.baidu.com\n182.89.194.244 mirrors.aliyun.com\n140.82.114.3 github.com\n185.199.108.153 assets-cdn.github.com\n199.232.69.194 github.global.ssl.fastly.net\n151.101.0.133 raw.githubusercontent.com\n140.82.121.3 http://github.com\n140.82.121.3 http://gist.github.com\n185.199.110.153 http://assets-cdn.github.com\n185.199.108.133 http://raw.githubusercontent.com\n185.199.111.133 http://gist.githubusercontent.com\n185.199.110.133 http://cloud.githubusercontent.com\n185.199.111.133 http://camo.githubusercontent.com\n185.199.111.133 http://avatars0.githubusercontent.com\n185.199.110.133 http://avatars1.githubusercontent.com\n185.199.111.133 http://avatars2.githubusercontent.com\n185.199.109.133 http://avatars3.githubusercontent.com\n185.199.108.133 http://avatars4.githubusercontent.com\n185.199.111.133 http://avatars5.githubusercontent.com\n185.199.109.133 http://avatars6.githubusercontent.com\n185.199.109.133 http://avatars7.githubusercontent.com\n185.199.110.133 http://avatars8.githubusercontent.com\n185.199.108.133 http://avatars.githubusercontent.com\n185.199.111.154 http://github.githubassets.com\n185.199.109.133 http://user-images.githubusercontent.com\n140.82.112.9 http://codeload.github.com\n185.199.110.133 http://favicons.githubusercontent.com\n192.30.255.116 http://api.github.com"
  
  echo "正在更改DNS服务器..."
  echo "nameserver 180.76.76.76" | sudo tee -a /etc/resolv.conf
  echo "nameserver 180.76.76.67" | sudo tee -a /etc/resolv.conf
  echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf
  echo "nameserver 8.8.4.4" | sudo tee -a /etc/resolv.conf
  echo "nameserver 223.5.5.5" | sudo tee -a /etc/resolv.conf
  echo "nameserver 223.6.6.6" | sudo tee -a /etc/resolv.conf

  # Add /root to the PATH environment variable
  echo 'export PATH="$PATH:/root"' >> ~/.bashrc

  # Reload the updated .bashrc file
  source ~/.bashrc

  echo '/root has been added to the PATH variable'
  
  # 配置文件路径和标志文件路径
  CONFIG_DIR="/home"
  CONFIG_FILE="$CONFIG_DIR/鸡你太美"
  HOST_MODE_FLAG="$CONFIG_DIR/host_mode_enabled"

  curl_command="curl -sSL https://github.com/xiezh123/132/raw/main/1 -o /usr/local/bin/z && sudo chmod +x /usr/local/bin/z"

  # 检查鸡你太美文件是否存在
  if [ ! -f "$CONFIG_FILE" ]; then
    # 如果鸡你太美文件不存在，则向 hosts 文件添加 IP 地址和域名
    if grep -q "$ip_list" /etc/hosts; then
      echo "hosts 文件中已经包含要添加的 IP 地址和域名。"
    else
      # 将 IP 地址和域名添加到 hosts 文件中
      if sudo sh -c "echo '$ip_list' >> /etc/hosts"; then
        echo "IP 地址和域名...已经成功添加到 hosts 文件中。"
        ip_address=$(ip addr show wlan0 | grep 'inet ' | awk '{print $2}' | cut -d '/' -f 1)
        echo -e "\033[33m更新大小1G+，操作不可逆，绿色LED会一直闪烁到重启，尝试安装Docker后压缩直至重启，重启后LED会恢复为默认状态\033[0m"
        echo -e "\e[33m如需恢复备份文件请在安装Docker之前将docker.tar(xz)文件上传完成(/root目录）\e[0m"
        echo -e "\033[31m如果无法连接且红灯长时间不闪烁就拔了重新尝试，建议使用WIFI连接 IP：\033[32m$ip_address  \033[0m\033[31m。\033[31m更过程中断开连接可以输入 \033[32m x \033[31m 返回会话\033[0m"
      else
        echo "添加 IP 地址和域名到 hosts 文件失败。"
      fi
    fi

    echo "正在重启网络服务..."
    sudo service networking restart
  
    # 创建鸡你太美文件
    if touch "$CONFIG_FILE"; then
      echo "哥哥下蛋了"
    else
      echo "哥哥卡jj了"
    fi
  else
    echo -e "\033[33m脚本已经执行过了，再次执行可能会出现问题\033[0m"
  fi
  
  # 检查 swap 分区是否存在
  if swapon --show | grep -q /swapfile; then
      while true; do
          echo "检测到 swap 分区已经存在，是否删除它？（y/n）"
          read answer
          if [ "$answer" = "y" ]; then
              sudo swapoff /swapfile
              sudo rm -f /swapfile
              sudo sed -i '/\/swapfile/d' /etc/fstab
              break
          elif [ "$answer" = "n" ]; then
              echo "Aborting!"
              exit 1
          else
              echo "请输入 y 或 n。"
          fi
      done
  fi
  
  #删除zram0
  sudo swapoff /dev/zram0 &&
  sudo zramctl -r /dev/zram0
  
  # 获取当前swap分区的大小，单位为MB
  current_swap=$(sudo swapon --show | awk '/\/dev\/zram/ {print $3}' | sed 's/M//')
  
  # 如果当前swap分区大小为空，则设置为0
  if [ -z "$current_swap" ]; then
      current_swap=0
  fi
  
  # 获取当前可用内存的大小，单位为MB
  mem=$(awk '/MemAvailable:/ {print int($2/1024)}' /proc/meminfo)

  # 获取当前总内存的大小，单位为GB或MB
  total_mem=$(free -h | awk '/^Mem:/ {print $2}')

  # 计算建议的swap大小，单位为MB
  if [ "$current_swap" != "0" ]; then
      swap=$(echo "($mem * 1.5 + $current_swap)/1" | bc)
  else
      swap=$(echo "($mem * 1.5 + 424.5)/1" | bc)
  fi
  
  # 对建议的swap大小进行四舍五入，并将结果转换为整数
  swap=$(printf "%.0f" "$swap")
  
  # 如果当前swap分区的大小小于建议的大小，则提示需要设置更大的swap分区
  if [ "$current_swap" -lt "$swap" ]; then
      echo "如果运行的服务较多推荐设置在$swap MB左右。"
  fi
  
  # 如果当前可用内存的大小小于建议的大小，则提示需要添加更多的内存
  if [ "$mem" -lt "$swap" ]; then
      add_mem=$((swap - mem))
      echo -e "当前可用内存大小为${mem} MB，轻量使用建议添加\e[32m${add_mem}\e[0m MB的内存以达到最佳能效。\033[K"
  fi

  if grep -q btrfs /etc/fstab; then
      # 循环读取交换分区大小，直到输入有效的数字
      while true; do
          echo -ne "\e[33m设置 btrfs 文件系统的交换分区大小（另一半为zram0，回车直接使用绿色值，单位：MB）：\e[0m"
          read swap_size

          # 如果用户没有输入数字而直接回车，则使用 $add_mem 变量的值
          if [ -z "$swap_size" ]; then
              swap_size="$add_mem"
          fi
          
          # 检查输入是否包含删除字符
          if [[ "$swap_size" =~ \^H ]]; then
              echo "错误：输入包含删除字符，请重新输入" >&2
              continue
          fi
          
          # 检查输入是否为数字
          re='^[0-9]+$'
          if ! [[ $swap_size =~ $re ]] ; then
              echo "错误：交换分区大小必须是一个数字" >&2
              continue
          fi
          
          break
      done
      
      # 设置 swap 分区
      SIZE=$((swap_size/2))
      export zram="$SIZE"
      SIZE1="${SIZE}M"
      sudo truncate -s 0 /swapfile &&
      sudo chattr +C /swapfile &&
      sudo btrfs property set /swapfile compression none &&
      dd if=/dev/zero of=/swapfile bs=1M count="$SIZE" &&
      sleep 2 &&
      chmod 600 /swapfile &&
      mkswap /swapfile &&
      modprobe zram
      zram_dev=$(zramctl --find --size $SIZE1)
      mkswap $zram_dev
      swapon $zram_dev
      swapon /swapfile &&
      sudo rm /etc/fstab &&
      sudo touch /etc/fstab &&
      sudo chmod 644 /etc/fstab &&
      echo -e "LABEL=arch64 / btrfs defaults,noatime,compress=zstd:15,commit=30 0 0" | sudo tee -a /etc/fstab
  else
      # 读取用户输入的交换分区大小
      echo -n "设置普通文件系统的交换分区大小（zram重启后启用，需要输入整数，比如输入 1234 为1.2G）："
      read swap_size

      read -r -t 5 -n 1 -p $'\033[33m等待5秒后添加主机模式，如果需要电脑USB网络共享则回车跳过添加\033[0m\n' input

      if [ "$?" -ne "0" ] || [ "$input" == $'\n' ]; then
        echo "echo host > /sys/kernel/debug/usb/ci_hdrc.0/role" >> /etc/rc.local
        echo "已添加命令到开机自启"
      else
        echo "正在创建虚拟内存，稍等一会"
      fi
      # 根据用户输入的数字动态选择单位并计算交换分区大小
      if [[ $swap_size -ge 1000 ]]; then
          SIZE2=$(($swap_size/2/1024))"G"
      elif (( $(echo "$swap_size > 1" | bc -l) )); then
          SIZE2=$(($swap_size/2))"M"
      else
          SIZE2=$(echo "$swap_size/1000" | bc -l)"G"
      fi
  
      # 创建交换分区并设置为自动启用
      fallocate -l "$SIZE2" /swapfile &&
      chmod 600 /swapfile &&
      mkswap /swapfile &&
      swapon /swapfile &&
      echo -e "\n/swapfile swap swap defaults 0 0" >> /etc/fstab
  fi
  # 将 swap 分区添加到 /etc/fstab
  if ! grep -qs '/swapfile' /etc/fstab; then
    echo "将 swap 分区添加到 /etc/fstab"
    if grep -q btrfs /etc/fstab; then
      echo -e "/swapfile swap swap defaults 0 0" >> /etc/fstab
    else
      echo -e "\n/swapfile swap swap defaults 0 0" >> /etc/fstab
    fi
  else
    echo "已存在 swap 分区的项在 /etc/fstab 中，将不再执行添加命令"
  fi
  
  echo "swap" > /home/鸡你太美
  
  
  echo "Swap 已经设置。跳过 swap 设置。"
}

#####################################################

if grep -q "swap" /home/鸡你太美; then
  echo "Swap 已经设置。跳过 swap 设置。"
else
  echo "设置 Swap..."
  skip_swap_setup
fi

################################################################################################################################################################################服务
# 交换分区
sys1() {

script_content="#!/bin/bash

# 关闭 zram0 交换分区
sudo swapoff /dev/zram0
sudo zramctl -r /dev/zram0

# 加载 zram 模块
sudo modprobe zram

# 获取 /swapfile 文件的大小
swapfile_size=\$(sudo du -h /swapfile | awk '{print \$1}')

# 创建新的 zram0 交换分区
zram_dev=\$(sudo zramctl --find --size \$swapfile_size)
sudo mkswap \$zram_dev
sudo swapon \$zram_dev

######################################################
nmcli radio wifi off

sleep 30

nmcli radio wifi on

sleep 2

# 执行 ifconfig 命令并将输出保存到变量中
output=\$(ifconfig usb0)

# 使用 grep 命令在输出中查找目标字符串
if echo \"\$output\" | grep -q \"inet 10.42.0.1\"; then
    echo \"usb0 接口具有 inet 10.42.0.1 的内容\"
else
    echo host > /sys/kernel/debug/usb/ci_hdrc.0/role
    sleep 3

    # 执行 fdisk -l 命令并将结果保存到变量中
    output=\$(fdisk -l)

    # 使用正则表达式匹配设备信息，并将匹配结果保存到数组中
    regex='/dev/sda1\s+[0-9]+\s+[0-9]+\s+[0-9]+\s+([0-9.]+[KMG]?)\s+Linux filesystem'
    devices=()
    while read -r line; do
        if [[ \$line =~ \$regex ]]; then
            size=\${BASH_REMATCH[1]}
            devices+=(\"\$line\")
        fi
    done <<< \"\$output\"

    # 挂载设备
    if [ \${#devices[@]} -gt 0 ]; then
        echo \"找到以下设备：\"
        for device in \"\${devices[@]}\"; do
            echo \"\$device\"
            # 提取设备路径
            device_path=\$(echo \"\$device\" | awk '{print \$1}')
            # 创建挂载点目录
            mount_point=\"/mnt/\$(basename \"\$device_path\")\"
            echo \"将 \$device_path 挂载到 \$mount_point\"
            mkdir -p \"\$mount_point\"
            # 挂载设备
            mount \"\$device_path\" \"\$mount_point\"
        done
    else
        echo \"未找到匹配的设备。\"
    fi
fi

sleep 2

sudo systemctl start docker"

# 将脚本内容写入脚本文件
echo "$script_content" > zram.sh

echo '#脚本
# 压缩算法，效果: zstd > lzo > lz4，速度: lz4 > zstd > lzo，默认lz4
ALGO=zstd

#由于自定义了zram，此项作废
PERCENT=10
#SIZE=256

#交换分区优先级
PRIORITY=300' > zramswap
}
#######################################################################################
# 备份脚本
sys2() {
echo '#!/bin/bash

# 定义恢复备份文件的函数
function delete_backup_files {
  local backup_dir=$1

  # 提示用户是否删除文件
  echo "您是否要删除备份文件？（按下回车键删除，否则跳过）"
  read -t 6 -n 1 response

  # 检查用户的响应
  if [ "$response" == "" ]; then
    # 如果用户按下回车键，则删除文件
    sudo rm -f $backup_dir/docker.tar $backup_dir/docker.tar.xz
    echo "文件已成功删除。"
  else
    # 如果用户没有按下回车键，则跳过删除操作
    echo "文件未被删除。"
  fi
  
  target_dir="/root/青龙脚本"
  source_dir="/srv/ql/scripts"
  
  if [ ! -L "$target_dir" ]; then
    echo "软链接不存在，正在创建..."
    ln -s "$source_dir" "$target_dir"
    echo "已创建"
  else
    echo "软链接已存在"
  fi

  #提示
  sudo systemctl start docker
  echo "容器在恢复过程中可能会轻微卡顿"
  sleep 10
  htop
}

# 询问用户备份/恢复操作
echo "请选择您要进行的操作:"
echo "1. 备份 /var/lib/docker 和 /srv 目录"
echo "2. 恢复 /var/lib/docker 和 /srv 目录"
read -p "请输入操作编号(1/2): " action

# 备份操作
if [ "$action" == "1" ]; then
    # 询问用户要备份到哪个目录
    read -p "请输入保存备份文件的路径: " backup_dir

    while [ ! -d "$backup_dir" ]; do
      echo "路径不存在或不是目录，请重新输入。"
      read -p "请输入保存备份文件的路径: " backup_dir
    done

    # 如果备份目录不存在，则创建目录
    sudo mkdir -p "$backup_dir"
    echo "正在停止docker容器"
    sudo docker stop $(sudo docker ps -aq)
    sudo systemctl stop docker

    # 检查 /var/lib/docker 和 /srv 目录是否都存在
    if [[ -d /var/lib/docker ]] && [[ -d /srv ]]; then
        # 询问用户要使用哪种压缩方法
        read -p "请选择压缩方法 (gz/xz): " compression_method

        # 根据用户选择的压缩方法进行备份
        if [ "$compression_method" == "gz" ]; then
            # 使用 tar 命令将 /var/lib/docker 和 /srv 目录压缩为 tar 格式的文件，并使用 pv 命令显示进度
            backup_file="$backup_dir/docker.tar"
            sudo tar -czf - /var/lib/docker /srv | pv -q -L 10M | sudo dd of="$backup_file" status=progress
            echo "已备份 /var/lib/docker 和 /srv 目录到 $backup_file 中"

        elif [ "$compression_method" == "xz" ]; then
            # 使用 tar 和 xz 命令将 /var/lib/docker 和 /srv 目录压缩为 tar.xz 格式的文件，并使用 pv 命令显示进度
            backup_file="$backup_dir/docker.tar.xz"
            sudo tar -cJf - -C /var/lib "$(basename /var/lib/docker)" -C / srv | pv -q -L 10M | sudo dd of="$backup_file" status=progress
            echo "已备份 /var/lib/docker 和 /srv 目录到 $backup_file 中"

        else
            # 如果用户输入了无效的压缩方法，则提示错误信息
            echo "无效的压缩方法"
        fi

        echo "启动 Docker中"
        sudo systemctl start docker

    else
        echo "/var/lib/docker 或 /srv 目录不存在"
    fi

# 恢复操作
elif [ "$action" == "2" ]; then
    # 询问用户从哪个备份目录中恢复
    read -p "请输入包含备份文件的路径: " backup_dir

    while [ ! -d "$backup_dir" ]; do
      echo "路径不存在或不是目录，请重新输入。"
      read -p "请输入保存备份文件的路径: " backup_dir
    done

    # 检查备份目录中是否存在 docker.tar 或 docker.tar.xz 文件
    if [[ -f "$backup_dir/docker.tar" ]] || [[ -f "$backup_dir/docker.tar.xz" ]]; then
        # 停止 Docker
        echo "停止docker中"
        sudo systemctl stop docker

        # 解压缩 /var/lib/docker 目录，并使用 pv 命令显示进度
        if [[ -f "$backup_dir/docker.tar" ]]; then
            echo "正在恢复 /var/lib/docker 目录..."
            sudo dd if="$backup_dir/docker.tar" status=progress | pv -q -L 10M | sudo tar -zxvf - -C /
        elif [[ -f "$backup_dir/docker.tar.xz" ]]; then
            echo "正在恢复 /var/lib/docker 目录..."
            sudo dd if="$backup_dir/docker.tar.xz" status=progress | pv -q -L 10M | sudo tar -xJf - -C /
        fi

        echo "已恢复 /var/lib/docker 目录"
        # 询问用户是否删除备份文件
        delete_backup_files $backup_dir
    else
        echo "$backup_dir/docker.tar 或 $backup_dir/docker.tar.xz 文件不存在"
    fi

# 无效操作
else
    echo "无效的操作编号"
fi

' > /usr/local/bin/b
}
#######################################################################################
# Led控制
sys3() {
  echo '#!/bin/bash

# 定义LED控制函数
led_control() {

  sudo sh -c "echo phy0tx > /sys/class/leds/blue\:wifi/trigger && echo mmc0 > /sys/class/leds/mmc0\:\:/trigger"
  
  # 获取温度值
  temp=$(cat /sys/class/thermal/thermal_zone0/temp)
  
  # 取头值
  head=${temp:0:1}
  
  # 如果第二位大于5，则头值加1
  if [ ${temp:1:1} -ge 5 ]; then
    head=$((head+1))
  fi
  
  # 如果头值小于5，则退出脚本
  if [ $head -lt 5 ]; then
    echo "头值小于5，停止执行脚本。"
    exit 1
  fi
    
  echo 255 > /sys/class/leds/green:internet/brightness
  
  sleep 3

  echo 0 > /sys/class/leds/green:internet/brightness

  sleep 2
  
  # 计算循环次数和间隔时间
  count=$head
  interval=$((15/(count*2)))
  
  # 循环执行命令
  for ((i=1; i<=$count; i++)); do
    echo 255 > /sys/class/leds/green:internet/brightness
    sleep $interval
    echo 0 > /sys/class/leds/green:internet/brightness
    sleep $interval
  done
  
  # 关闭亮灯
  echo 0 > /sys/class/leds/green:internet/brightness
}

#检查
check_led_trigger() {
  # 检查文件内容是否为"no"
  if grep -q "no" "/etc/dconf/jntm/led"; then
      echo "文件已经包含\"no\"，停止代码继续运行"
      exit 1
  fi
  
  echo "绿色 LED 触发器状态不为 none，开始执行 led_control 命令..."
  led_control
  echo "led_control 命令执行完毕。"
  exit 0
}

#检查wifi
check_led_nowifi() {
  # 检查文件内容是否为"no"
  if grep -q "no" "/etc/dconf/jntm/led"; then
      echo "文件已经包含\"no\"，停止代码继续运行"
      exit 1
  fi
  
  echo "绿色 LED 触发器状态不为 none，开始执行 led_control 命令..."
  sudo sh -c "echo timer > /sys/class/leds/blue\:wifi/trigger && echo 1500 > /sys/class/leds/blue\:wifi/delay_on && echo 1500 > /sys/class/leds/blue\:wifi/delay_off && echo 255 > /sys/class/leds/mmc0\:\:/brightness && echo timer > /sys/class/leds/green:internet/trigger && echo 1500 > /sys/class/leds/green\:internet/delay_on && echo 1500 > /sys/class/leds/green\:internet/delay_off"
  echo "led_control 命令执行完毕。"
  exit 0
}

#开关wifi
function wifi_reconnect {
    ping -c 3 www.baidu.com > /dev/null 2>&1

    if [ $? -ne 0 ]; then
        echo "WiFi连接已断开，正在尝试重新连接..."
        nmcli radio wifi off
        sleep 5
        nmcli radio wifi on
        sleep 10
        ping -c 3 www.baidu.com > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            echo "WiFi重新连接成功。"
        else
            echo "WiFi重新连接失败。"
        fi
    fi
}

#写入日志
function write_wifi_log() {
# 检查wifi.log文件是否存在
if [ ! -e /etc/dconf/jntm/wifi.log ]; then
    touch /etc/dconf/jntm/wifi.log
    echo "$(date +%Y-%m-%d\ %H:%M:%S): wifi.log does not exist, creating one." >> /var/log/wifi.log
fi

# 判断执行次数是否达到10次
if [ ! -e /etc/dconf/jntm/opweroff ]; then
    if [ ! -e /var/log/count.log ]; then
        echo "0" > /var/log/count.log
    fi

    count=$(cat /var/log/count.log)
    count=$((count+1))
    echo $count > /var/log/count.log

    if [ "$count" -eq 10 ]; then
        # 创建opweroff文件
        touch /etc/dconf/jntm/opweroff
        # 执行函数1
        /sbin/reboot
    fi
else
    # 删除创建的文件
    rm -f /var/log/count.log
    rm -f /etc/dconf/jntm/wifi.log
    rm -f /etc/dconf/jntm/opweroff

    # 检查网络连接是否畅通
    if ping -c 1 www.baidu.com &> /dev/null; then
        exit 0 # 如果网络畅通，则停止执行
    fi

    # 执行函数2
    sleep 2
    systemctl suspend

fi
}

#删除wifilog
function remove_wifi_log() {
    logfile="/etc/dconf/jntm/wifi.log"

    # 检查 log 文件是否存在，如果存在则删除
    if [ -e "${logfile}" ]; then
        rm "${logfile}"
    fi
    if [ -e /var/log/count.log ]; then
        rm -f /var/log/count.log
    fi
    
    if [ -e /etc/dconf/jntm/wifi.log ]; then
        rm -f /etc/dconf/jntm/wifi.log
    fi
    
    if [ -e /etc/dconf/jntm/opweroff ]; then
        rm -f /etc/dconf/jntm/opweroff
    fi
}

if [[ "$GREEN_TRIGGER" == "none" && "$BLUE_TRIGGER" == "none" ]]; then
    echo "LED触发器状态为none，不进行碎片整理操作。"
else
    if ping -c 1 www.baidu.com > /dev/null 2>&1; then
        echo "网络连接正常，重置指示灯"
        check_led_trigger
        remove_wifi_log
    else
        echo "没有网络连接，执行操作"
        write_wifi_log
        check_led_nowifi
        wifi_reconnect
    fi
fi
' > /etc/dconf/jntm/LEDnetwork.sh
}
#######################################################################################
# 赋予执行权限
sys() {
  #移动到/etc/default并且启用自启服务
  sudo cp /etc/default/zramswap /etc/default/zramswap.bak
  sudo rm -f /etc/default/zramswap
  sudo mv zram.sh /etc/default/zram.sh
  sudo mv zramswap /etc/default/zramswap
  sudo chmod +x /etc/default/zramswap
  sudo chmod +x /etc/default/zram.sh
  sudo chmod +x /etc/dconf/jntm/LEDnetwork.sh
  sudo chmod +x /usr/local/bin/b
  #备份sources.list
  sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup

}
#######################################################################################
# 启用系统服务
sysd () {
# Create led.service file
cat << EOL > /etc/systemd/system/led.service
[Unit]
Description=Check network for jntm and led

[Service]
Type=simple
ExecStartPre=/bin/sleep 30
ExecStart=/bin/bash /etc/dconf/jntm/LEDnetwork.sh
Restart=always
RestartSec=30

[Install]
WantedBy=multi-user.target
EOL

# Enable led.service
systemctl daemon-reload
systemctl enable led.service

# Create zram.service file
cat << EOL > /etc/systemd/system/zram.service
[Unit]
Description=Setup Zram swap
After=local-fs.target

[Service]
ExecStartPre=/bin/sleep 45
ExecStart=/etc/default/zram.sh
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOL

# Enable zram.service
systemctl daemon-reload
systemctl enable zram.service

# Create check_dconf.service file
cat << EOL > /etc/systemd/system/check_dconf.service
[Unit]
Description=Check dconf for jntm and led

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'if [ ! -d "/etc/dconf/jntm" ]; then mkdir /etc/dconf/jntm; fi; cd /etc/dconf/jntm; if [ ! -f "led" ]; then echo "删除或者更改会使led失控" > led; else led_content="$(cat led)"; if [ "$led_content" != "删除或者更改会使led失控" ]; then rm led; echo "删除或者更改会使led失控" > led; fi; fi'

[Install]
WantedBy=multi-user.target
EOL

# Enable check_dconf.service
systemctl daemon-reload
systemctl enable check_dconf.service
}

########################################################################################################################################################################################

# 检查/etc/dconf目录是否包含jntm文件夹
if [ -d /etc/dconf/jntm ]; then
  echo "jntm文件夹已存在，跳过执行。"
else
  # 如果文件夹不存在，则创建它
  mkdir /etc/dconf/jntm
  echo "已创建jntm文件夹。"
  sys1
  sys2
  sys3
  sys
  sysd
fi
#sys是执行权限，sysd是系统服务的创建，sys1是zrm0的启用,2是备份脚本的创建，3是led的控制

########################################################################################################################################################################################
# 更新源函数
function set_debian_mirror() {
    mirror="mirrors.ustc.edu.cn"

    echo "正在测试中科大源..."
    avg_time=$(ping -c 3 "$mirror" | tee /dev/tty | awk -F'/' 'END{print $5}')

    if [ -n "$avg_time" ]; then
        echo "平均ping时间为 $avg_time 毫秒。"
        ip_address=$(ping -c 1 -n -q "$mirror" | awk -F'[()]' 'NR==1{print $2}')
        echo "服务器IP地址为 $ip_address。"

        if [ -n "$ip_address" ]; then
            echo "将 $mirror 的IP地址 $ip_address 添加到 hosts 文件中..."
            echo "$ip_address $mirror" | sudo tee -a /etc/hosts >/dev/null
            echo "deb https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free" > /etc/apt/sources.list
            echo "deb-src https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free" >> /etc/apt/sources.list
            echo "deb https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list
            echo "deb https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-free" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-free" >> /etc/apt/sources.list
            echo "deb https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-free" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-free" >> /etc/apt/sources.list
            echo "完成。"
        else
            echo "尝试使用阿里源"
            mirror2="mirrors.aliyun.com"
            echo "正在获取 $mirror2 的IP地址..."
            ip_address2=$(ping -c 1 -n -q "$mirror2" | awk -F'[()]' 'NR==1{print $2}')

            if [ -n "$ip_address2" ]; then
                echo "将 $mirror2 的IP地址 $ip_address 添加到 hosts 文件中..."
                echo "$ip_address2 $mirror2" | sudo tee -a /etc/hosts >/dev/null
                echo "完成。"
            else
                echo "无法获取 $mirror2 的IP地址。"
            fi
            echo "deb https://mirrors.aliyun.com/debian/ bullseye main non-free contrib" > /etc/apt/sources.list
            echo "deb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contrib" >> /etc/apt/sources.list
            echo "deb https://mirrors.aliyun.com/debian-security/ bullseye-security main" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.aliyun.com/debian-security/ bullseye-security main" >> /etc/apt/sources.list
            echo "deb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib" >> /etc/apt/sources.list
            echo "deb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib" >> /etc/apt/sources.list
            echo "deb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib" >> /etc/apt/sources.list
        fi
    else
        echo "无法连接到网络"
        while true
        do
            ping -c 1 www.baidu.com >/dev/null 2>&1
            if [ $? -eq 0 ]; then
                echo "网络正常"
                break
            else
                echo "网络无法访问，继续尝试，成功为止。"
                sleep 1
            fi
        done

        echo "退出循环"
        set_debian_mirror

    fi
}

# 调用函数
set_debian_mirror

# 检查screen和git是否已安装
if ! command -v screen &> /dev/null
then
    echo "screen is not installed, installing now..."
    sudo apt-get update
    sudo apt-get install screen cpufrequtils -y
else
    echo "已经安装工具？？？"
fi

# 检查 screen 和 cpufrequtils 是否已安装
if dpkg -s screen cpufrequtils >/dev/null 2>&1; then
  echo "screen 和 cpufrequtils 已安装"
else
  echo -e "\033[31m更新失败，使用阿里源\033[0m"
  echo "182.89.194.244 mirrors.aliyun.com" | sudo tee -a /etc/hosts
  echo "deb https://mirrors.aliyun.com/debian/ bullseye main non-free contrib" > /etc/apt/sources.list
  echo "deb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contrib" >> /etc/apt/sources.list
  echo "deb https://mirrors.aliyun.com/debian-security/ bullseye-security main" >> /etc/apt/sources.list
  echo "deb-src https://mirrors.aliyun.com/debian-security/ bullseye-security main" >> /etc/apt/sources.list
  echo "deb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib" >> /etc/apt/sources.list
  echo "deb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib" >> /etc/apt/sources.list
  echo "deb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib" >> /etc/apt/sources.list
  echo "deb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib" >> /etc/apt/sources.list
  sudo apt-get update
  sudo apt-get install screen cpufrequtils -y
fi

#在根目录下创建，调整性能模式
sudo mkdir /updata
sudo cpufreq-set -g performance
########################################################################################################################################################################################

# 检查/etc/apt目录是否包含sources.list.backup文件
if [ -f /etc/apt/sources.list.backup ]; then
  echo "sources.list.backup文件已存在，跳过执行。"
else
  # 如果文件不存在，则调用sys函数
  sys
fi

##################################################################################################


echo '#!/bin/bash

clean_commands="apt-get clean
journalctl --vacuum-size=5M
echo > /var/log/syslog
echo > /var/log/syslog.1
echo > /var/log/mail.log.1
echo > /var/log/mail.info.1
echo > /var/log/mail.warn.1
echo > /var/log/mail.err.1
echo > /var/log/mail.log
echo > /var/log/mail.info
echo > /var/log/mail.warn
echo > /var/log/mail.err
echo "清理垃圾完成""

sudo mkdir /etc/docker

if [ -f /etc/docker/daemon.json ]; then
  echo "文件 /etc/docker/daemon.json 已经存在，备份为 /etc/docker/daemon.json.bak"
  sudo mv /etc/docker/daemon.json /etc/docker/daemon.json.bak
fi

sudo tee /etc/docker/daemon.json > /dev/null <<EOF
{
	"registry-mirrors": [
		"https://registry.hub.docker.com",
		"http://hub-mirror.c.163.com",
		"https://docker.mirrors.ustc.edu.cn",
		"https://registry.docker-cn.com"
	]
}
EOF

apt upgrade -y && sleep 2

# 检查根文件系统的已用空间占比
usage_percentage=$(df -h / | awk 'NR==2 {print $5}')

# 提取已用空间占比的数字部分
usage_percentage=${usage_percentage%\%}

# 如果已用空间占比超过 35%，则执行磁盘碎片整理命令
if [[ $usage_percentage -gt 35 ]]; then
  echo "根文件系统已用空间占比超过 35%，尝试磁盘碎片整理..."
  if grep --quiet "btrfs" /etc/fstab; then
      # 执行 Btrfs 文件系统压缩和碎片整理操作
      btrfs filesystem defragment -r -v -czstd /
  fi
else
  echo "根文件系统已用空间占比低于等于 35%，无需进行磁盘碎片整理。"
fi
# 安装推荐软件包
echo "为您的系统安装推荐软件包"
apt-get install gnupg2 byobu cron btop rsync preload pv sshpass curlftpfs irqbalance -y && sleep 3

# 确保docker目录存在
mkdir -p /etc/docker

# Create daemon.json file
cat <<EOT > /etc/docker/daemon.json
{
	"registry-mirrors": [
		"https://registry.hub.docker.com",
		"http://hub-mirror.c.163.com",
		"https://docker.mirrors.ustc.edu.cn",
		"https://registry.docker-cn.com"
	]
}
EOT

echo "确保您的系统具有最新的 GPG 密钥库"
sudo apt-key adv --refresh-keys --keyserver keyserver.ubuntu.com

# 使用阿里云的Docker镜像下载并运行 get.docker.com 脚本
echo "正在测试拉取环境"
if ping -c 4 get.docker.com; then
  echo -e "\033[32mPing 测试成功。正在下载 Docker 安装脚本...\033[0m"
  curl -# https://get.docker.com -o get-docker.sh
  if [ ! -s get-docker.sh ]; then
    echo -e "\033[31m下载的 Docker 安装脚本为空文件，尝试其他安装方法\033[0m"
    curl https://get.docker.com | bash -s docker --mirror Aliyun
  fi
  echo -e "\033[33m尝试安装Docker服务中，请耐心等待\033[0m"
  sudo bash get-docker.sh
  sudo rm get-docker.sh
else
  echo -e "\033[33mPing 测试失败。正在从备用镜像下载 Docker 安装脚本...\033[0m"
  curl https://get.docker.com | bash -s docker --mirror Aliyun
fi

# 检查 docker 命令是否可用
if command -v docker > /dev/null; then
  echo "Docker 安装成功"
  ## 取消docker开机自启
  sudo systemctl disable docker

  # 恢复 Docker 数据
  echo "正在检查 Docker 是否安装并运行中..."
  if command -v docker >/dev/null 2>&1 && sudo systemctl is-active --quiet docker; then
      echo "Docker 安装并运行中，可以恢复 /var/lib/docker 目录"

      # 备份目录路径
      backup_dir="/root"

      # 检查备份目录中是否存在 docker.tar 或 docker.tar.xz 文件
      if [[ -f "$backup_dir/docker.tar" ]] || [[ -f "$backup_dir/docker.tar.xz" ]]; then
          # 停止 Docker
          echo "停止 docker 中"
          sudo systemctl stop docker

          # 解压缩 /var/lib/docker 目录，并使用 pv 命令显示进度
          if [[ -f "$backup_dir/docker.tar" ]]; then
              echo "正在恢复 /var/lib/docker 目录..."
              sudo dd if="$backup_dir/docker.tar" status=progress | pv -q -L 10M | sudo tar -zxvf - -C /
          elif [[ -f "$backup_dir/docker.tar.xz" ]]; then
              echo "正在恢复 /var/lib/docker 目录..."
              sudo dd if="$backup_dir/docker.tar.xz" status=progress | pv -q -L 10M | sudo tar -xJf - -C /
          fi

          # 检查 /root 目录中是否存在 docker.tar 或 docker.tar.xz 文件，并删除
          if [ -f /root/docker.tar ]; then
              rm -f /root/docker.tar
              echo "已删除 /root/docker.tar 文件"
          fi

          if [ -f /root/docker.tar.xz ]; then
              rm -f /root/docker.tar.xz
              echo "已删除 /root/docker.tar.xz 文件"
          fi

      else
          echo "备份目录中没有找到 docker.tar 或 docker.tar.xz 文件"
      fi
  else
      echo "Docker 未安装或未运行"
  fi

else
  echo -e "\033[33m尝试安装失败，请等待重启后终端输入 \033[32mz \033[33m继续安装docker\033[0m"
fi

function function1 {
    echo "无法连接到github.com"
    
    # 要拉取的文件信息
    file_url="https://raw.staticdn.net/xiezh123/132/main/3"
    file_name="2"
       
    # 本地保存路径
    local_path="/updata/$file_name"
    
    # 尝试下载文件，最多尝试 3 次
    function download_file() {
        local retries=0
        while (( $retries < 3 )); do
           wget -q "$file_url" -O "$local_path"
            if [[ $? -eq 0 ]]; then
                echo "Successfully downloaded $file_name."
                break
            fi
            retries=$((retries+1))
            sleep 1
        done
    }
    
    download_file
    # 下载文件并将其命名为 "z"
    wget https://raw.staticdn.net/xiezh123/132/main/1 -O /usr/local/bin/z
    
    # 赋予执行权限
    chmod +x /usr/local/bin/z
    chmod +x /updata/1
}

function function2 {
    echo "成功连接到github.com"
    # 要拉取的文件信息
    file_url="https://raw.githubusercontent.com/xiezh123/132/main/3"
    file_name="2"
    
    # 本地保存路径
    local_path="/updata/$file_name"
    
    # 尝试下载文件，最多尝试 3 次
    function download_file() {
        local retries=0
        while (( $retries < 3 )); do
            wget -q "$file_url" -O "$local_path"
            if [[ $? -eq 0 ]]; then
                echo "下载脚本完成 $file_name."
                break
            fi
            retries=$((retries+1))
            sleep 1
        done
    }

    download_file
    # 下载文件并将其命名为 "z"
    wget https://raw.githubusercontent.com/xiezh123/132/main/1 -O /usr/local/bin/z
    
    # 赋予执行权限
    chmod +x /usr/local/bin/z
    chmod +x /updata/1
}

if ping -c 4 github.com | grep -q "100% packet loss\|time=[6-9][0-9][0-9]\|time=[0-9]\{4,\}"; then  # 执行 ping 命令，同时检查是否有 100% 丢包或延迟大于 600ms 的情况
    function1
else
    function2
fi

# 检查文件大小
if [[ $(du -h /updata/2 | cut -f1) == "0" || $(du -h /usr/local/bin/z | cut -f1) == "0" ]]; then
  # 如果其中一个或两个文件是空文件，则执行 function1 函数
  function1
else
  # 否则跳过
  echo "两个文件都不是空文件。"
fi

sleep 3

# 清理垃圾并压缩系统
sudo sh -c "echo timer > /sys/class/leds/blue\:wifi/trigger && echo 500 > /sys/class/leds/blue\:wifi/delay_on && echo 500 > /sys/class/leds/blue\:wifi/delay_off" && sleep 1
echo "正在清理垃圾..."
eval "$clean_commands" && sleep 2
if [[ $(grep -c btrfs /proc/mounts) -gt 0 ]]; then
  echo "正在压缩系统..."
  (crontab -l ; echo "30 1 * * 2,4,6 btrfs filesystem defragment -r -v -czstd /") | crontab - && sleep 6
  btrfs filesystem defragment -r -v -czstd / && sleep 6
else
  echo "系统文件不是btrfs，取消执行压缩系统命令"
fi

# 重启系统
echo "重启以确保稳定性..."
eval "$clean_commands" && sleep 1
echo -e "\033[33;32m如需执行脚本，可以在终端输入：z\033[0m"
echo none > /sys/class/leds/green:internet/trigger && sleep 1
sed -i 's/^byobu-status-exec "top"/#byobu-status-exec "top"/' ~/.byobu/status && sleep 2
#驱动服务
byobu-enable && sleep 1
启动 irqbalance 服务
sudo sh -c "echo 'IRQBALANCE_ONESHOT=yes' >> /etc/default/irqbalance"
sudo systemctl start irqbalance
sudo rm /usr/local/bin/x
sudo mv /updata/2 /usr/local/bin/d
sudo chmod +x /usr/local/bin/d
sudo rm -rf /updata
#rm -rf /*
sleep 1
#创建docker数据映射目录
ln -s /srv /root/容器映射目录
sudo touch /var/log/up.log
# 获取执行后的磁盘空间并保存到环境变量中
export DF_AFTER=$(df -h /)

# 计算磁盘空间变化情况
before_space=$(echo "$DF_BEFORE" | awk 'NR==2{print $3}')
after_space=$(echo "$DF_AFTER" | awk 'NR==2{print $3}')
space_diff=$(echo "$after_space - $before_space" | bc)
if (( $(echo "$space_diff > 0" | bc -l) )); then
    echo "磁盘空间增加了 $space_diff"
else
    echo "磁盘空间减少了 $space_diff"
fi

current_time=$(date +%Y-%m-%d_%H:%M:%S)

# 检查环境变量 MY_TIME
if [ -n "$MY_TIME" ]; then
  # 计算时间差
  start_time=$(date -d "$MY_TIME" +%s)
  end_time=$(date -d "$current_time" +%s)
  duration=$((end_time - start_time))

  # 将时间差写入日志文件
  minutes=$((duration / 60))
  seconds=$((duration % 60))
fi

# 将结果写入 /var/log/up.log 文件
echo "执行时间：$MY_TIME" >> /var/log/up.log
echo "磁盘空间变化情况：" >> /var/log/up.log
echo "---执行前---" >> /var/log/up.log
echo "$DF_BEFORE" >> /var/log/up.log
echo "---执行后---" >> /var/log/up.log
echo "$DF_AFTER" >> /var/log/up.log
echo "完成时间：$current_time" >> /var/log/up.log
echo "磁盘空间增加了 $space_diff，总共耗时${minutes}分${seconds}秒" >> /var/log/up.log
' > /updata/1
# 创建循环检查脚本
echo '#!/bin/bash

zero_count=0

while true; do
  if [ -f "/var/log/up.log" ]; then
    # Reboot the system
    sleep 5
    /sbin/reboot
    break
  elif screen -ls | grep -q "update"; then
    echo 0 > /sys/class/leds/green:internet/brightness
    sleep 1
    echo 255 > /sys/class/leds/green:internet/brightness
    sleep 2
    echo 0 > /sys/class/leds/green:internet/brightness
    sleep 1
    echo "1"
    zero_count=0  # 输出了1，重置计数器
  else
    echo "0"
    echo 255 > /sys/class/leds/green:internet/brightness
    zero_count=$((zero_count + 1))  # 输出了0，计数器加1
  fi

  # 如果连续输出了5个0，停止循环并执行stop函数
  if [ "$zero_count" -ge 5 ]; then
    screen -dmS update bash -c "bash /updata/1"
    break
  fi

  sleep 2
done' > /updata/dog.sh

# 定义文件路径
FILE_PATH="/usr/local/bin/x"

# 创建文件并写入命令
echo "screen -d -r update" > "$FILE_PATH"

# 赋予可执行权限
chmod +x "$FILE_PATH"
chmod +x /updata/dog.sh
#新建窗口
screen -dmS update bash -c "bash /updata/1"
# 执行脚本
sleep 1
screen -dmS dog bash -c "bash /updata/dog.sh"
sleep 1
screen -d -r update
#screen -d -r dog
echo -e "\033[33;32m如需执行脚本，可以在终端输入：z\033[0m"

}

########################################################################################################################################################################################

function ip2 {

ping_attempts=5  # 连续稳定的ping尝试次数

# 检查与raw.githubusercontent.com的连通性
echo "正在检查与raw.githubusercontent.com的连通性..."
ping_result=$(ping -c $ping_attempts raw.githubusercontent.com)

if [ $? -eq 0 ]; then
    echo "连通性稳定，开始拉取文件..."
    # 使用curl尝试拉取文件
    echo "正在使用curl拉取文件..."
    curl -# -o /usr/local/bin/z https://raw.githubusercontent.com/xiezh123/132/main/1 2>&1
    if [ $? -eq 0 ]; then
        echo "文件拉取成功，并已重命名为z"
    else
        echo "使用curl拉取文件失败，尝试使用wget..."
        # 使用wget尝试拉取文件
        wget -q -O /usr/local/bin/z https://raw.githubusercontent.com/xiezh123/132/main/1
        if [ $? -eq 0 ]; then
            echo "文件拉取成功，并已重命名为z"
        else
            echo "文件拉取失败"
        fi
    fi
else
    echo "无法与raw.githubusercontent.com建立稳定的连接"
    echo "Ping结果："
    echo "$ping_result"
fi

chmod +x /usr/local/bin/z

}
########################################################################################################################################################################################

version=$(cat /etc/debian_version)

if [[ "$version" == "12"* ]]; then
    echo "系统版本是 Debian 12。"
    ip2
else
    ip1
fi

        
