#!/bin/bash

#检查变量
FILE_PATH=/home/鸡你太美
my_var=$(last | grep "pts/[0-9]" | grep "still logged in" | awk '{print $1}' | uniq -c)

if [ $(systemctl is-active docker) = "active" ]; then
    if grep -q "docker" $FILE_PATH; then
        echo "docker already exists in the file."
    elif grep -q "no docker" $FILE_PATH; then
        sed -i 's/no docker/docker/g' $FILE_PATH
        echo "no docker has been replaced with docker in the file."
    else
        echo "docker" >> $FILE_PATH
        echo "docker has been added to the file."
    fi
else
    if grep -q "no docker" $FILE_PATH; then
        echo "no docker already exists in the file."
    elif grep -q "docker" $FILE_PATH; then
        sed -i 's/docker/no docker/g' $FILE_PATH
        echo "docker has been replaced with no docker in the file."
    else
        echo "no docker" >> $FILE_PATH
        echo "no docker has been added to the file."
   fi
fi

hour=$(date +%H)

if ! pgrep docker >/dev/null; then
    echo "Docker未运行。正在启动Docker..."
    sudo systemctl start docker
elif ((hour >= 5 && hour < 12)); then
    echo "早上好！欢迎使用脚本！"
elif ((hour >= 12 && hour < 18)); then
    echo "下午好！欢迎使用脚本！"
else
    echo "晚上好！欢迎使用脚本！"
fi
# 检查 Docker 是否安装
if command -v docker > /dev/null; then
  # 获取磁盘空间信息
  df_info=$(df -h /)
    
  # 解析磁盘空间信息
  partition=$(echo "$df_info" | awk 'NR==2{print $1}')
  used=$(echo "$df_info" | awk 'NR==2{print $3}')
  available=$(echo "$df_info" | awk 'NR==2{print $4}')
  total=$(echo "$df_info" | awk 'NR==2{print $2}')
  percent=$(echo "$df_info" | awk 'NR==2{print $5}')
  # 保存life_time的值到变量lifetime中
  lifetime=$(cat /sys/class/mmc_host/mmc0/mmc0\:0001/life_time)
  # 输出磁盘空间信息
  printf "磁盘分区：%s | 已用空间：%s | 可用空间：%s | 总共空间：%s | 参考寿命：%s | 使用比例：%s\n" "$partition" "$used" "$available" "$total" "$lifetime" "$percent" 

  # 获取当前系统的网络接口名称
  interface=$(ip route | awk '/^default/ {print $5}')

  # 获取当前网络接口的总共使用流量
  rx=$(cat /sys/class/net/${interface}/statistics/rx_bytes)
  tx=$(cat /sys/class/net/${interface}/statistics/tx_bytes)

  # 计算总共使用流量
  total=$((rx + tx))

  # 定义流量单位数组
  units=(B KB MB GB TB PB EB ZB YB)
  # 循环遍历流量单位数组，选择合适的单位
  unit=0
  while [ ${total} -gt 1024 ] && [ ${unit} -lt 8 ]; do
      total=$(echo "${total}/1024" | bc)
      unit=$((unit+1))
  done
  # 获取 CPU 温度
  cpu_temp=$(cat /sys/class/thermal/thermal_zone0/temp)

  # 将温度除以 1000，以得到以摄氏度为单位的温度
  cpu_temp_c=$(echo "scale=2; $cpu_temp/1000" | bc)

  # 获取系统内存和交换分区信息，并将结果存储在变量中
  mem_info=$(free -h | awk 'NR==2{printf "%s/%s\n", $7, $2}')

  # 获取所有 zram 设备的使用情况，并将结果存储在变量中
  zram_info=$(sudo zramctl | awk 'NR>1{printf "%s/%s（%s，%s/%s/%s） ", $4, $3, $1, $2, $5, $7}')

  # 执行 swapon -s 命令，并将结果存储到变量中
  swap_info=$(swapon -s)

  # 提取 /swapfile 的大小和使用情况
  swapfile_size=$(echo "$swap_info" | grep '/swapfile' | awk '{print $3}')
  swapfile_used=$(echo "$swap_info" | grep '/swapfile' | awk '{print $4}')
  # 将 /swapfile 的大小和使用情况转换为 MB
  swapfile_size_mb=$(echo "scale=2; $swapfile_size/1024" | bc)
  swapfile_used_mb=$(echo "scale=2; $swapfile_used/1024" | bc)

  # 输出总共使用流量
  echo "使用的流量：${total} ${units[$unit]}，CPU 温度为：$cpu_temp_c°C，可用/总共: $mem_info，swap：$swapfile_used_mb/$swapfile_size_mb MB，zram ：$zram_info"

  # 获取所有容器信息
  container_info=$(docker ps -a --format "{{.Names}}|{{.State}}")
  # 循环遍历所有容器信息，输出到一行中，并用竖线隔开
  output=""
  for info in $container_info
  do
      # 提取容器名称和状态信息
      name=$(echo $info | cut -d "|" -f 1)
      state=$(echo $info | cut -d "|" -f 2)

      # 检查容器状态是否为 running
      if [[ $state == "running" ]]; then
          # 如果容器正在运行，标记为绿色
          output+="\033[32m$name\033[0m | "
      else
          # 如果容器未运行，使用黄色
          output+="\033[33m$name\033[0m | "
      fi
  done
  # 去掉输出字符串末尾的竖线和空格
  output=${output% | }

  # 输出所有容器名称
  echo -e "容器状态：$output"
else
  echo "Docker没有安装，正在拉取安装脚本..."

  # 执行 Docker 安装脚本
  apt update && apt upgrade
  bash <(curl -sSL https://linuxmirrors.cn/docker.sh)

  # 检查 Docker 是否安装成功
  if command -v docker > /dev/null; then
    echo -e "\033[32mDocker成功！请输入1后选择安装\033[0m"
  else
    echo -e "\033[33mDocker 安装失败，请输入1或者回车后继续选择安装\033[0m"
  fi
fi
echo "请选择要执行的操作："
echo "1. 安装工具"
echo "2. 其他命令"
echo "3. 快捷命令"
echo "   a. 关闭LED"
echo "   b. 清理垃圾&压缩系统"
echo "   c. 查看网络信息"
echo "   d. 查看系统状态"

clean_commands="apt-get clean
journalctl --vacuum-size=5M
echo > /var/log/syslog
echo > /var/log/syslog.1
echo > /var/log/mail.log.1
echo > /var/log/mail.info.1
echo > /var/log/mail.warn.1
echo > /var/log/mail.err.1
echo > /var/log/mail.log
echo > /var/log/mail.info
echo > /var/log/mail.warn
echo > /var/log/mail.err
echo "清理垃圾完成""

read -p "请输入选项（1、2、3、3a、3b、3c、3d）：" option

if [ "$option" == "1" ]; then
  echo "请选择要执行的操作："
  echo "a. 安装Docker"
  echo "b. 安装ql"
  echo "c. 安装1Panel"
  echo "d. 安装bt"
  echo "e. 安装Aria2"
  echo "f. 安装Alist"
  echo "g. 安装CasaOS"
  echo "h. 安装qiandao"
  echo "i. 安装UnblockNeteaseMusic"
  echo "j. 安装Hsaa"
  read -p "请输入字母选项：" install_option

  if [ "$install_option" == "a" ]; then
    echo "请选择安装docker的镜像源（可能需要稳定的网络环境）："
    echo "1. 使用Docker官方源"
    echo "2. 使用阿里云镜像源"
    echo "3. 使用DaoCloud镜像源"
    echo "4. 移动docker目录"
    echo "5. 删除Docker及其相关文件和设置"
    read -p "请输入选项（1、2、3、4）：" option
    if [ "$option" == "1" ]; then
    echo "从Docker官方安装Docker"
    curl -fsSL https://get.docker.com -o get-docker.sh
    sudo sh get-docker.sh
    elif [ "$option" == "2" ]; then
      echo "从阿里云安装Docker"
      curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
    elif [ "$option" == "3" ]; then
      echo "从DaoCloud安装Docker"
      curl -sSL https://get.daocloud.io/docker | sh
    elif [ "$option" == "4" ]; then
      echo "拉取脚本中，执行迁移操作可能会出现问题，自行解决"
      sudo curl -sSL https://raw.githubusercontent.com/xiezh123/132/main/3 -o /root/Quick/3 && sudo bash /root/Quick/3
    elif [ "$option" == "5" ]; then
      echo "确认删除 Docker 及其相关文件和设置（如需恢复请更新软件包，如安装docker—ce）"
      sudo docker stop $(sudo docker ps -aq)
      sudo systemctl stop docker && sudo apt-get purge docker-ce docker-ce-cli containerd.io && sudo rm -rf /var/lib/docker /etc/docker && sudo groupdel docker && sudo userdel -r docker && sudo rm -rf /etc/systemd/system/docker.service.d /etc/systemd/system/containerd.service.d /lib/systemd/system/docker.service /lib/systemd/system/containerd.service
    echo "Docker 已被删除"
    else
      echo "无效的选项"
      exit 1
    fi

    echo "启用 Docker 服务..."
    sudo systemctl enable docker
    echo -e "\e[33m请查看 Docker 守护进程的状态信息，出现 \e[32mActive: active (running)\e[33m 即可，安装出错请尝试到：脚本>2>a，修复软件包或更换源\e[0m"
    sudo systemctl start docker && sleep 3
    systemctl status docker
  elif [ "$install_option" == "b" ]; then
    echo "请选择您要安装的版本："
    echo "1. 安装 Debian 版本"
    echo "2. 安装正式版"
    echo "3. 安装 2.10.13 稳定版"
    echo "4. 进入容器"
    source_dir="/srv/ql/scripts"
    target_dir="/root/青龙脚本"
    read panel_option

    if [ "$panel_option" == "1" ]; then
        echo "安装 Debian 版本..."
        ## 执行安装命令
        docker pull whyour/qinglong:debian && sleep 2
        docker run -dit \
        -v /srv/ql:/ql/data \
        -p 5700:5700 \
        --name qinglong \
        --hostname qinglong \
        --restart always \
        whyour/qinglong:debian &&
        ln -s "$source_dir" "$target_dir"
    elif [ "$panel_option" == "2" ]; then
        echo "安装正式版..."
        ## 执行安装命令
        docker run -dit \
        -v /srv/ql:/ql/data \
        -p 5700:5700 \
        --name qinglong \
        --hostname qinglong \
        --restart always \
        whyour/qinglong:latest &&
        ln -s "$source_dir" "$target_dir"
    elif [ "$panel_option" == "3" ]; then
        echo "安装 2.10.13 稳定版..."
        ## 执行安装命令
        docker run -dit \
        -v /srv/ql/config:/ql/config \
        -v /srv/ql/log:/ql/log \
        -v /srv/ql/db:/ql/db \
        -v /srv/ql/scripts:/ql/scripts \
        -v /srv/ql/jbot:/ql/jbot \
        -v /srv/ql/repo:/ql/repo \
        -v /srv/ql/ninja:/ql/ninja \
        -v /srv/ql/raw:/ql/raw \
        -p 5960:5700 \
        -p 5701:5701 \
        -e ENABLE_HANGUP=true \
        -e ENABLE_WEB_PANEL=true \
        --name ql \
        --hostname ql \
        --privileged=true \
        --restart always \
        whyour/qinglong:2.10.13 &&
        ln -s "$source_dir" "$target_dir"
    elif [ "$panel_option" == "4" ]; then
        echo "进入容器，按住 Ctrl 和 PQ 退出容器，执行 ql -l check 修复面板"
        echo "2.10.13 稳定版执行 docker exec -it qinglong bash -c "$(curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/FlechazoPh/QLDependency/main/Shell/QLOneKeyDependency.sh | sh)"
 安装依赖，如果查看不全，自行打开脚本查看"
        docker exec -it qinglong /bin/bash
    else
        echo "无效的选项，退出脚本"
    fi
  elif [ "$install_option" == "c" ]; then
    echo "安装1Panel面板"
    echo "如果需要备份数据，可以将其安装在/srv目录下"
    curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh && bash quick_start.sh
    # 删除名称包含关键字1panel的文件或文件夹
    find /root -maxdepth 1 -name "*1panel*" -exec rm -rf {} +
    # 删除名为quick_start.sh的文件
    rm -f /root/quick_start.sh
  elif [ "$install_option" == "d" ]; then
    echo "安装宝塔开心版，安装完成后终端执行<bt>自行更改"
    wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh && sudo bash install.sh
  elif [ "$install_option" == "e" ]; then
    echo "安装Aria2"
    apt-get update
    apt-get install -y aria2
  elif [ "$install_option" == "f" ]; then
    echo "安装Alist网盘,IP:5244,帐密请查看输出内容"
    curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s install
  elif [ "$install_option" == "g" ]; then
    echo "安装CasaOS个人云,IP"
    wget https://get.casaos.io -O casaos.sh && bash casaos.sh
  elif [ "$install_option" == "h" ]; then
    echo "安装qiandao,IP:8923"
    docker run --restart=always -d --name qiandao -p 8923:80 -v /srv/qiandao/config:/usr/src/app/config a76yyyy/qiandao:lite-latest
  elif [ "$install_option" == "i" ]; then
    echo "安装网易云音乐解灰,代理端口6666"
    # athr=nondanee && img=unblockneteasemusic && \
    athr=pan93412 && img=unblock-netease-music-enhanced && \
    docker rm -f $img 2>/dev/null || true && \
    docker rmi -f $athr/$img 2>/dev/null || true && \
    docker run -d \
    --name $img \
    --restart always \
    -p 6666:8080 \
    $athr/$img \
    -p 8080:8081 \
    -s -e https://music.163.com -f 59.111.19.33 \
    -o kuwo qq
  elif [ "$install_option" == "j" ]; then
    sudo docker run -d --name hass --restart=always -p 8123:8123 -v /srv/hass:/config homeassistant/home-assistant
    echo "端口：8123"
  else
    echo "选项不存在"
  fi
elif [ "$option" == "2" ]; then
  echo "请选择要执行的操作："
  echo "a. 检查并修复软件包"
  echo "b. 关机"
  echo "c. 禁用系统日志"
  echo "d. 深度清理文件"
  echo "e. 添加主机模式"
  echo "f. 更改CPU频率"
  echo "g. 查看emmc"
  echo "h. LED控制选项"
  echo "i. 安装桌面（xfce）"
  echo "j. 添加push推送"
  read -p "请输入选项（a、b、c、d、e）：" check_option

  if [ "$check_option" == "a" ]; then
    echo "正在检查并更新软件包..."
    echo -e '\xE2\xA0\x84\xE2\xA0\x84\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA0\x98\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xA7\xE2\xA3\x9B\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA0\xA4\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBD\xE2\xA1\x86\xE2\xA0\x84\xE2\xA0\x84'
    apt-get check && apt-get -f install
    sleep 1
    sudo apt-get update && sleep 2 && sudo apt --fix-broken install
  elif [ "$check_option" == "b" ]; then
    echo "正在关机..."
    sudo shutdown -h now
  elif [ "$check_option" == "c" ]; then
    echo "正在清空系统日志..."
    sudo systemctl stop rsyslog && sudo systemctl disable rsyslog && sudo systemctl stop systemd-journald && sudo systemctl disable systemd-journald && sudo cat /dev/null > /var/log/syslog && sudo cat /dev/null > /var/log/messages && sudo cat /dev/null > /var/log/auth.log && sudo cat /dev/null > /var/log/user.log && sudo cat /dev/null > /var/log/kern.log && sudo cat /dev/null > /var/log/mysql/error.log && sudo find /var/log -type f -delete && sudo rm -rf /var/log/* && sudo rm -rf /tmp/* && sudo rm -rf /var/tmp/*
  elif [ "$check_option" == "d" ]; then
    read -p "警告：执行此操作可能会造成系统不稳定甚至崩溃，按回车键确认继续执行，出现英文提示时CTRL&C退出：" confirm
    if [ -z "$confirm" ]; then
      echo "正在深度清理文件..."
        if ! command -v bleachbit &> /dev/null
  then
      echo "Bleachbit not found. Installing..."
      sudo apt-get update && sudo apt-get install -y bleachbit
  fi

  echo "Cleaning system..."
  bleachbit --clean system.*
    else
      echo "已取消执行操作"
    fi
  elif [ "$check_option" == "e" ]; then
    read -p "警告：执行此操作将向 rc.local 文件添加一行命令，可能会影响系统稳定性。按回车键确认继续执行：" confirm
    if [ -z "$confirm" ]; then
      echo "正在添加主机模式..."
      sudo sed -i '/exit 0/i\sleep 45\necho host > /sys/kernel/debug/usb/ci_hdrc.0/role' /etc/rc.local
    else
      echo "已取消执行操作"
    fi
  elif [ "$check_option" == "f" ]; then
  # 检查 cpufrequtils 是否已安装，如果未安装则自动安装
  if ! dpkg -s cpufrequtils > /dev/null 2>&1 ; then
      echo "cpufrequtils 尚未安装，正在安装..."
      sudo apt-get install cpufrequtils -y
  fi

  # 显示选择菜单
  echo "请选择 CPU 频率："
  echo "1. 动态调整"
  echo "2. 800 MHz"
  echo "3. 1000 MHz"
  echo "4. 1.20 GHz"
  echo "5. 1.40 GHz"
  echo "6. 1.60 GHz"
  echo "7. 1.80 GHz"
  echo "8. 2.00 GHz"
  echo "9. 2.10 GHz"

  # 读取用户输入
  read -p "请输入数字 [1-9]: " choice

  # 根据用户输入修改 CPU 频率
  case $choice in
    1) sudo cpufreq-set -g ondemand ;;
    2) sudo cpufreq-set -c 0 -f 800000 ;;
    3) sudo cpufreq-set -c 0 -f 1000000 ;;
    4) sudo cpufreq-set -c 0 -f 1200000 ;;
    5) sudo cpufreq-set -c 0 -f 1400000 ;;
    6) sudo cpufreq-set -c0 -f 1600000 ;;
    7) sudo cpufreq-set -c 0 -f 1800000 ;;
    8) sudo cpufreq-set -c 0 -f 2000000 ;;
    9) sudo cpufreq-set -c 0 -f 2100000 ;;
    *) echo "错误的输入" ;;
  esac

  echo "CPU 频率已修改为："
  sudo cpufreq-info | grep "current CPU frequency"
  elif [ "$check_option" == "g" ]; then
    cat /sys/class/mmc_host/mmc0/mmc0\:0001/life_time
  elif [ "$check_option" == "h" ]; then
    bash -c "$(curl -L gitee.com/ojf6ii/led-control-script/raw/master/led.sh)"
  elif [ "$check_option" == "i" ]; then
    read -p "需要4g左右空间，安装速度由棒子体质决定，输入x返回会话，回车继续"
    # 检查screen和git是否已安装
    if ! command -v screen &> /dev/null
    then
        echo "安装screen"
        sudo apt-get install screen -y
    else
        echo "安装工具1"
    fi
    echo '#!/bin/bash
    sudo apt-get update && sudo apt-get install xrdp -y && sleep 3
    sudo service xrdp start -y && apt-get install task-xfce-desktop -y && sleep 3
    sudo apt-get install -y openssh-server
    sudo systemctl start ssh
    btrfs filesystem defragment -r -v -czstd / && sleep 3
    wget https://dldir1.qq.com/qqfile/qq/QQNT/ad5b5393/linuxqq_3.1.2-13107_arm64.deb && sudo dpkg -i linuxqq_3.1.2-13107_arm64.deb
    sudo rm /root/linuxqq_3.1.2-13107_arm64.deb
    sudo rm /root/Desktop.sh
    sudo rm /usr/local/bin/x' > Desktop.sh
    sleep 2
    sudo chmod +x /root/Desktop.sh
    # 定义文件路径
    FILE_PATH="/usr/local/bin/x"
    FILE="screen -d -r Desktop"
    # 创建文件并写入命令
    echo "$FILE" > "$FILE_PATH"
    sudo chmod +x /usr/local/bin/x
    #新建窗口
    screen -dmS Desktop bash -c "bash /root/Desktop.sh"
    sleep 2
    $FILE
    GREEN='\033[0;32m'
NC='\033[0m' # No Color
echo -e "${GREEN}请使用远程桌面客户端连接到服务器，使用root用户名和密码登录。${NC}"
  elif [ "$check_option" == "j" ]; then
    # 设置拉取次数
    max_attempts=2
    attempts=0

    # 设置文件名和路径
    file_name="push"
    file_path="/srv/$file_name"
    # 检查是否能够 ping 通 raw.githubusercontent.com
    ping -c 1 raw.githubusercontent.com > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        url="https://raw.githubusercontent.com/xiezh123/132/main/6.sh"
    else
        url="https://raw.staticdn.net/xiezh123/132/main/6.sh"
    fi
    # 尝试拉取文件
    while [ $attempts -lt $max_attempts ]; do
        attempts=$((attempts+1))
        echo "正在尝试从 $url 拉取文件，第 $attempts 次尝试..."
        if curl -# -o "$file_path" "$url" > /dev/null 2>&1; then
            if [ -s "$file_path" ]; then
                echo "成功拉取文件 $file_name 到 $file_path"
                while true; do
                  # 获取用户输入的MyToken值
                  echo -e "\033[33m请前往push官方网站，登录并且复制Token\033[0m"
                  read -p "请输入Token值： " -n 32 my_token
                  # 检查输入是否为32位十六进制数字
                  if [[ ! $my_token =~ ^[0-9a-fA-F]{32}$ ]]; then
                    echo -e "\033[31m输入不正确，请输入32位十六进制数字。\033[0m"
                  else
                    # 将MyToken值写入push文件
                    sed -i "s/MyToken=\"[0-9a-fA-F]*\"/MyToken=\"$my_token\"/" /srv/push
                    echo "MyToken值已更新为：$my_token"
                    break
                  fi
                done
                bash /srv/push
                echo -e "\033[32m已经执行推送，请查看是否成功。\033[0m"
                exit 0
            fi
        fi
    done
    echo "无法拉取文件 $file_name"
    exit 1
  else
    echo "选项不存在"
  fi
elif [[ "$option" == "3a" ]]; then
  # 显示 LED 控制菜单
  echo "请选择 LED 控制选项：（回车关闭）"
  echo "1. 保留WiFi（默认情况）"
  echo "2. 蓝绿互换"
  read -r led_option
  
  # 处理 LED 控制选项
  case "$led_option" in
    1)
      # 关闭其他 LED
      echo 0 > /sys/class/leds/mmc0\:\:/brightness #红灯
      echo none > /sys/class/leds/green\:internet/trigger #绿灯
      ;;
    2)
      # LED 互换
      echo heartbeat > /sys/class/leds/blue\:wifi/trigger
      echo phy0tx > /sys/class/leds/green\:internet/trigger
      ;;
    *)
      # 默认情况：关闭 LED
      echo "关闭 LED"
      echo 0 > /sys/class/leds/mmc0\:\:/brightness #红灯
      echo none > /sys/class/leds/blue\:wifi/trigger #蓝灯
      echo none > /sys/class/leds/green\:internet/trigger #绿灯
      export LED=1
      ;;
  esac
elif [[ "$option" == "3b" ]]; then 
  echo "清理垃圾"
  eval "$clean_commands"

  ROOT_PARTITION=$(mount | grep "on / " | cut -d' ' -f1)
  if [ "$(lsblk -o FSTYPE "$ROOT_PARTITION" | tail -n1)" == "btrfs" ]; then 
    echo "根文件系统为 btrfs，执行相关操作"
    btrfs filesystem defragment -r -v -czstd /
  else 
    echo "根文件系统不是 btrfs，跳过相关操作"
  fi 
elif [[ "$option" == "3c" ]]; then 
  echo "查看网络信息"
  ip addr show
  ping -c 4 baidu.com
  ping -c 4 google.com
  mmcli -m 0
elif [[ "$option" == "3d" ]]; then 
  echo "查看系统状态"
  echo "系统详情：$(uname -a)"
  echo "CPU 信息：$(lscpu)"
  echo "内存占用情况：$(free -h)"
  echo "Swap 占用情况：$(swapon -s)"
  echo "磁盘挂载情况：$(lsblk)"
  echo "存储占用情况：$(df -h)"
  # ANSI 转义序列，用于添加颜色
  green='\033[0;32m'
  yellow='\033[0;33m'
  blue='\033[0;34m'
  magenta='\033[0;35m'
  cyan='\033[0;36m'
  reset='\033[0m' # 重置颜色
  
  # 获取所有正在运行的容器的ID和名称
  container_info=$(docker ps --format '{{.ID}}|{{.Names}}')

  # 循环遍历容器ID和名称，并输出容器信息
  while IFS='|' read -r container_id container_name; do
    echo -e "${green}容器ID：$container_id${reset}"
    echo -e "${yellow}容器名称：$container_name${reset}"

    # 输出容器状态信息
    echo -e "${blue}状态：$(docker inspect --format='{{.State.Status}}' $container_id)${reset} | ${magenta}创建时间：$(docker inspect --format='{{.Created}}' $container_id)${reset} | ${cyan}IP地址：$(docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $container_id)${reset}"
    echo ""

    # 输出容器端口映射信息
    echo -e "${blue}端口映射：${reset}"
    docker port $container_id
    echo ""

    # 输出容器挂载的卷信息
    echo -e "${blue}挂载的卷：${reset}"
    docker inspect --format='{{range .Mounts}}{{printf "%s:%s\n" .Type .Source}}{{end}}' $container_id
    echo ""

  done <<< "$container_info"
else
  echo "选项不存在"
  z
fi
