#!/bin/bash
############################################################登录提示
ssh_prompt() {
# uname -snrvm
echo "-------------------------- 系统信息 --------------------------"
echo "操作系统: $(echo "$(sed 's/\\n//g;s/\\l//g' /etc/issue)")" || echo "操作系统: $(uname -o)"
echo "主机名称: $(hostname)"
echo "内核版本: $(uname -r)"
echo "软件包数量: $(dpkg --list | wc -l)"
echo "CPU架构: $(lscpu| awk '/Architecture:/ {print $NF}')"
echo "CPU核心数: $(lscpu| awk '/^CPU\(s\)/ {print $2}')"
echo "核心线程数: $(lscpu| awk '/Thread\(s\) per core:/ {print $NF}')"
echo "CPU温度: $(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null | awk '{print int($1/1000)}')°C"

if output=$(mmcli -m 0 2>&1) && [ -n "$output" ]; then
get_modem() { mmcli -m 0 2>/dev/null | grep -oiP "(?<=$1\s).*" | awk 'NR==1{print}'; };
echo "-------------------------- Modem信息 --------------------------"
[ -n "$(get_modem "own:")" ] && echo "SIM号码: $(get_modem "own:" | sed 's/^86//')"
[ -n "$(get_modem "operator name:")" ] && echo "运营商: $(get_modem "operator name:" | sed 's/CHN-UNICOM/中国联通/g; s/UNICOM/中国联通/g; s/CMCC/中国移动/g; s/CT/中国电信/g')"
[ -n "$(get_modem "state:")" ] && echo "SIM状态: $(get_modem "state:")"
[ -n "$(get_modem "power state:")" ] && echo "数据开关: $(get_modem "power state:")"
[ -n "$(get_modem "access tech:")" ] && echo "访问类型: $(get_modem "access tech:")"
[ -n "$(get_modem "signal quality:")" ] && echo "信号强度: $(get_modem "signal quality:")"
[ -n "$(get_modem "equipment id:")" ] && echo "设备ID: $(get_modem "equipment id:")"
fi

ip_address=$(ip addr show | grep -w inet | awk '{print $2}' | cut -d/ -f1)
if [ -n "$ip_address" ]; then
echo "-------------------------- 网络信息 --------------------------"
echo "内网IP:"
echo "$ip_address"
curl_output=$(curl -s -m 6 cip.cc 2>&1 | sed '/^$/d') && [ -n "$curl_output" ] && {
echo "公网IP:"
echo "$curl_output"; };
fi

interfaces=$(ifconfig | awk '/^[^ ]/ && !/lo/ {gsub(/:/,"");print $1}')
if [ -n "$interfaces" ]; then
echo "-------------------------- 接口信息 --------------------------"
echo "网络接口: "$interfaces""
convert_unit() { size=$1; awk 'BEGIN{ printf "%.2f %s", ('$size'/1024/1024), "MB" }'; }
for interface in $interfaces; do
get_bytes() { ifconfig $interface | grep -E "$1 .*bytes|$1 bytes" | sed -E "s/.*$1 bytes:([0-9]+).*/\1/;s/.*bytes ([0-9]+) .*/\1/"; }
rx=$(get_bytes RX)
tx=$(get_bytes TX)
[ $rx -gt 0 -o $tx -gt 0 ] && echo "$interface 接收: $(convert_unit $rx) 发送: $(convert_unit $tx)"
done;fi

echo "-------------------------- 内存信息 --------------------------"
mmc_info=$(cat /sys/class/mmc_host/mmc0/mmc0\:0001/life_time)
[ -n "$mmc_info" ] && echo "内存寿命: $mmc_info"
echo "硬件内存: $(free -m | awk 'NR==2{printf "%s/%sMiB (%.2f%%)\n", $3,$2,$3*100/$2 }')"
swap_info=$(free -m | awk 'NR==3{printf "%s/%sMiB (%.2f%%)\n", $3,$2,$3*100/$2}')
[ ! -z "$swap_info" ] && echo "虚拟内存: $swap_info" && sudo swapon --show

echo "-------------------------- 磁盘信息 --------------------------"
df -h

echo "-------------------------- 运行信息 --------------------------"
uptime=$(uptime | sed 's/up/已运行:/g; s/mins/分钟/g; s/min/分钟/g; s/days/天/g; s/day/天/g; s/users/个登录用户/g; s/user/个登录用户/g; s/load average/平均负载/g')
echo "本地时间: $uptime"
echo ""
}

if [ "$1" = "ssh_prompt" ]; then
  ssh_prompt
  return
fi
############################################################热点设置
wifisys_hotspot() {
    # 检查 /etc/environment 文件是否含有变量 4Gwifi
    if grep -q "4Gwifi=" /etc/environment; then
        # 执行 nmcli connection show 命令，并将输出保存到变量中
        output=$(nmcli connection show)
        # 检查是否存在包含 "modem" 的连接
        connection_name=$(echo "$output" | awk '/modem/ {print $1}')
        if [ -n "$connection_name" ]; then
          # 检查连接是否已激活
          active_connection=$(echo "$output" | awk '/[[:space:]]+connected[[:space:]]+/ {print $1}')
          if [ "$active_connection" == "$connection_name" ]; then
            echo -e "连接已经激活: \e[32m$active_connection\e[0m"
          else
            # 激活连接
            nmcli connection up "$connection_name"
            echo -e "已激活连接: \e[32m$connection_name\e[0m"
          fi
        else
          echo "未找到包含 'modem' 的连接"
        fi
        sleep 1
        # 执行 nmcli connection show 命令，并将输出保存到变量中
        output=$(nmcli connection show)

        # 检查输出是否包含 hotspot 变量的值
        if [[ $output =~ $hotspot ]]; then
            # 查找名字以 wifi. 或 wifi- 开头的文件，并匹配 hotspot 变量
            files=$(ls /etc/NetworkManager/system-connections/ | grep -E '^wifi(\.|-).*' | grep -v "$hotspot")
            # 删除匹配的文件（保留 hotspot 对应的文件）
            for file in $files; do
                rm "/etc/NetworkManager/system-connections/$file"
            done
            # 执行 nmcli 连接热点
            hotspot="$hotspot" nmcli connection up "$hotspot"
        else
            # 读取 /etc/environment 文件中的 4Gwifi 变量
            four_g_wifi=$(grep -oP '^4Gwifi=\K.*' /etc/environment)
            # 拆分名字和密码
            IFS='//' read -r name password <<< "$four_g_wifi"
            # 输出名字和密码
            echo "名字: $name"
            echo "密码: $password"
            # 如果不一致则启用热点并且向 $hotspot 写入新的 UUID
            output3=$(nmcli d wifi hotspot ifname wlan0 con-name wifi ssid "$name" band bg channel 11 password "$password") # 更改名字密码为变量
            # 提取连接的 UUID
            uuid1=$(echo "${output3}" | awk '{print $2}')
            # 去除双引号和前缀 "wlan0"
            uuid1=${uuid1//\"/}
            uuid1=${uuid1#wlan0}
            # 去除另一行的 "nmcli"
            uuid1=$(echo "$uuid1" | sed '/^$/d' | sed 's/nmcli//g')
            # 将 UUID 写入文件
            echo "$uuid1"
            # 检查 /etc/environment 文件是否存在
            if [[ -f /etc/environment ]]; then
                # 检查 /etc/environment 文件中是否已经定义了变量 $hotspot
                if grep -q "^hotspot=" /etc/environment; then
                    # 如果已经定义了变量 $hotspot，则使用 sed 命令进行替换
                    sed -i "s/^hotspot=.*/hotspot=$uuid1/" /etc/environment
                else
                    # 如果没有定义变量 $hotspot，则在文件末尾添加新的变量定义
                    echo "hotspot=$uuid1" >> /etc/environment
                fi
            fi
        fi
    else
        echo "变量 4Gwifi 不存在。跳过创建热点。"
    fi
    # 检查环境变量的值
    if [[ "${GWiFi1}" == "1" ]]; then
        echo "环境变量 GWiFi1 的值为 1"
    elif [[ "${GWiFi1}" == "0" ]]; then
        output5=$(byobu-enable 2>&1)
        if [[ $output5 == *"byobu-disable"* ]]; then
            echo "Byobu 已启用"
            byobu-disable
            sleep 1
            byobu-enable
        else
            echo "Byobu 未启用"
            byobu-disable
            sleep 1
            byobu-enable
        fi
        echo "环境变量 GWiFi1 的值为 0"
        # 执行其他操作...
    else
        echo "环境变量 GWiFi1 的值不是 0 或 1。"
        # 执行其他操作...
    fi
}

if [ "$1" = "wifisys_hotspot" ]; then
  wifisys_hotspot
  return
fi
############################################################DOCKER备份
function dockerbackupfiles() {

function dockerbackup() {

# 定义恢复备份文件的函数
function delete_backup_files {

  # 提示用户是否删除文件
  backup_dir="$dockerfile"
  echo "您是否要删除备份文件？（按下回车键删除，否则跳过）"
  read -t 6 -n 1 response

  # 检查用户的响应
  if [ "$response" == "" ]; then
    # 如果用户按下回车键，则删除文件
    sudo rm -f $backup_dir/docker.tar $backup_dir/docker.tar.xz
    echo "文件已成功删除。"
  else
    # 如果用户没有按下回车键，则跳过删除操作
    echo "文件未被删除。"
  fi
  
  target_dir="/root/青龙脚本"
  source_dir="/srv/ql/scripts"
  
  if [ ! -L "$target_dir" ]; then
    echo "软链接不存在，正在创建..."
    ln -s "$source_dir" "$target_dir"
    echo "已创建"
  else
    echo "软链接已存在"
  fi

  #提示
  sudo systemctl start docker
  echo "容器在恢复过程中可能会轻微卡顿"
  sleep 10
  htop
}

# 询问用户备份/恢复操作
echo -e "\033[0;33m请选择您要进行的Docker文件操作:\033[0m"
echo "1. 备份docker文件夹和映射目录（只备份/srv）"
echo "2. 恢复docker文件夹和映射目录（只恢复/srv）"
read -p "请输入操作编号(1/2): " action

# 备份操作
if [ "$action" == "1" ]; then
    # 询问用户要备份到哪个目录
    read -p "请输入保存备份docker文件的路径: " backup_dir
    if [ -z "$backup_dir" ]; then
      backup_dir="/root"  # 如果用户输入为空，则使用默认值 /root
      echo -e "\033[33m已经设置docker文件保存在/root目录\033[0m"
      sleep 3
    fi

    while [ ! -d "$backup_dir" ]; do
      echo "路径不存在或不是目录，请重新输入。"
      read -p "请输入保存备份文件的路径: " backup_dir
    done

    # 如果备份目录不存在，则创建目录
    sudo mkdir -p "$backup_dir"
    echo "正在停止docker容器"
    sudo docker stop $(sudo docker ps -aq)
    sudo systemctl stop docker

    # 检查 /var/lib/docker 和 /srv 目录是否都存在
    if [[ -d /var/lib/docker ]] && [[ -d /srv ]]; then
        # 询问用户要使用哪种压缩方法
        read -t 5 -p "请选择压缩方法 (gz/xz): " compression_method
        compression_method=${compression_method:-gz}  # 如果用户没有输入，则使用默认值 gz

        # 根据用户选择的压缩方法进行备份
        if [ "$compression_method" == "gz" ]; then
            # 使用 tar 命令将 /var/lib/docker 和 /srv 目录压缩为 tar 格式的文件，并使用 pv 命令显示进度
            echo -e "\033[33m提示不用管\033[0m"
            backup_file="$backup_dir/docker.tar"
            sudo tar -czf - /var/lib/docker /srv | pv -q -L 10M | sudo dd of="$backup_file" status=progress
            echo "已备份 /var/lib/docker 和 /srv 目录到 $backup_file 中"

        elif [ "$compression_method" == "xz" ]; then
            # 使用 tar 和 xz 命令将 /var/lib/docker 和 /srv 目录压缩为 tar.xz 格式的文件，并使用 pv 命令显示进度
            backup_file="$backup_dir/docker.tar.xz"
            echo -e "\033[33m提示不用管\033[0m"
            sudo tar -cJf - -C /var/lib "$(basename /var/lib/docker)" -C / srv | pv -q -L 10M | sudo dd of="$backup_file" status=progress
            echo "已备份 /var/lib/docker 和 /srv 目录到 $backup_file 中"

        else
            # 如果用户输入了无效的压缩方法，则提示错误信息
            echo "无效的压缩方法"
        fi

        echo "启动 Docker中"
        sudo systemctl start docker
        htop
    else
        echo "/var/lib/docker 或 /srv 目录不存在"
        dockerbackupfiles
    fi

# 恢复操作
elif [ "$action" == "2" ]; then
    # 询问用户从哪个备份目录中恢复
    read -p "请输入包含docker文件的路径: " backup_dir
    
    if [ -z "$backup_dir" ]; then
      backup_dir="/root"  # 如果用户输入为空，则使用默认值 /root
      echo -e "\033[33m已经选择/root目录\033[0m"
      sleep 3
    fi
    
    while [ ! -d "$backup_dir" ]; do
      echo "路径不存在或不是目录，请重新输入。"
      read -p "请输入保存备份文件的路径: " backup_dir
    done
    export dockerfile="$backup_dir"
    # 检查备份目录中是否存在 docker.tar 或 docker.tar.xz 文件
    if [[ -f "$backup_dir/docker.tar" ]] || [[ -f "$backup_dir/docker.tar.xz" ]]; then
        # 停止 Docker
        echo "停止docker中"
        sudo systemctl stop docker

        # 解压缩 /var/lib/docker 目录，并使用 pv 命令显示进度
        if [[ -f "$backup_dir/docker.tar" ]]; then
            echo "正在恢复 /var/lib/docker 目录..."
            sudo dd if="$backup_dir/docker.tar" status=progress | pv -q -L 10M | sudo tar -zxvf - -C /
        elif [[ -f "$backup_dir/docker.tar.xz" ]]; then
            echo "正在恢复 /var/lib/docker 目录..."
            sudo dd if="$backup_dir/docker.tar.xz" status=progress | pv -q -L 10M | sudo tar -xJf - -C /
        fi

        echo "已恢复 /var/lib/docker 目录"
        # 询问用户是否删除备份文件
        delete_backup_files $backup_dir
    else
        echo "$backup_dir/docker.tar 或 $backup_dir/docker.tar.xz 文件不存在"
        dockerbackupfiles
    fi

# 无效操作
else
    echo "无效的操作编号"
    dockerbackupfiles
fi

}

function show_menu() {
    # 获取所有容器信息
    container_info=$(docker ps -a --format "{{.Names}}")
    image_info=$(docker ps -a --format "{{.Names}}:{{.Image}}")

    # 列出所有容器及其状态
    echo "可用容器："
    index=1
    for container in $container_info
    do
        container_status=$(docker inspect -f '{{.State.Status}}' $container)

        if [[ $container_status == "running" ]]; then
            echo -e "\033[32m$index. $container\033[0m"
        else
            echo -e "\033[33m$index. $container\033[0m"
        fi

        ((index++))
    done

    # 读取用户输入
    read -p "请输入命令和容器序号（例如 q1-启动，s2-停止，d3-删除或者直接回车）: " input

    if [[ -z $input ]]; then
        # 如果用户直接按回车，则执行备份函数
        dockerbackup
    else
        # 提取容器序号和命令
        number=${input:1}
        command=${input:0:1}

        # 根据命令执行相应操作
        if [[ $number -gt 0 && $number -le ${#container_info[@]} ]]; then
            container_name=$(echo "$container_info" | awk "NR==$number")
            case $command in
                "q")
                    # 启动容器
                    docker start $container_name
                    echo "正在启动容器：$container_name"

                    # 等待5秒钟检查容器状态
                    sleep 5
                    container_status=$(docker inspect -f '{{.State.Status}}' $container_name)

                    if [[ $container_status == "running" ]]; then
                        echo "已成功启动容器：$container_name"
                    else
                        echo "容器启动失败，请稍后重试。"
                        docker start $container_name

                        # 等待5秒钟再次检查容器状态
                        sleep 5
                        container_status=$(docker inspect -f '{{.State.Status}}' $container_name)

                        if [[ $container_status == "running" ]]; then
                            echo "已成功启动容器：$container_name"
                        else
                            read -p "容器启动失败，是否删除该容器？（按回车删除）" choice
                            if [[ -z $choice ]]; then
                                # 检查容器关联的镜像
                                container_image=$(echo "$image_info" | grep "$container_name:" | awk -F: '{print $2}')
                                read -p "是否删除容器关联的镜像 $container_image？[Y/N]: " image_choice
                                if [[ $image_choice == "Y" || $image_choice == "y" ]]; then
                                    docker rm -f $container_name
                                    docker rmi $container_image
                                    echo "已删除容器：$container_name"
                                    echo "已删除镜像：$container_image"
                                else
                                    docker rm $container_name
                                    echo "已删除容器：$container_name"
                                    echo "未删除镜像：$container_image"
                                fi
                            else
                                echo "未删除容器：$container_name"
                            fi
                        fi
                    fi
                    ;;
                "s")
                    # 停止容器
                    docker stop $container_name
                    echo "已停止容器：$container_name"
                    ;;
                "d")
                    # 删除容器
                    # 检查容器关联的镜像
                    container_image=$(echo "$image_info" | grep "$container_name:" | awk -F: '{print $2}')
                    read -p "是否删除容器关联的镜像 $container_image？[Y/N]: " image_choice
                    if [[ $image_choice == "Y" || $image_choice == "y" ]]; then
                        docker rm -f $container_name
                        docker rmi $container_image
                        echo "已删除容器：$container_name"
                        echo "已删除镜像：$container_image"
                    else
                        docker rm $container_name
                        echo "已删除容器：$container_name"
                        echo "未删除镜像：$container_image"
                    fi
                    ;;
                *)
                    echo "无效的命令，请重新输入。"
                    ;;
            esac
        else
            echo "无效的容器序号，请重新输入。"
        fi
    fi

    echo "--------分割线-----------------------分割线---------"
    show_menu
}

# 菜单循环
show_menu

}
if [ "$1" = "dockerbackupfiles" ]; then
  dockerbackupfiles
  return
fi
###############################################################################################################################
#检查变量
FILE_PATH=/var/log/鸡你太美
my_var=$(last | grep "pts/[0-9]" | grep "still logged in" | awk '{print $1}' | uniq -c)

if [ $(systemctl is-active docker) = "active" ]; then
    if grep -q "docker" $FILE_PATH; then
        echo "docker already exists in the file."
    elif grep -q "no docker" $FILE_PATH; then
        sed -i 's/no docker/docker/g' $FILE_PATH
        echo "no docker has been replaced with docker in the file."
    else
        echo "docker" >> $FILE_PATH
        echo "docker has been added to the file."
    fi
else
    if grep -q "no docker" $FILE_PATH; then
        echo "no docker already exists in the file."
    elif grep -q "docker" $FILE_PATH; then
        sed -i 's/docker/no docker/g' $FILE_PATH
        echo "docker has been replaced with no docker in the file."
    else
        echo "no docker" >> $FILE_PATH
        echo "no docker has been added to the file."
   fi
fi

hour=$(date +%H)

if ! pgrep docker >/dev/null; then
    echo "Docker未运行。"
elif ((hour >= 5 && hour < 12)); then
    echo "早上好！欢迎使用脚本！"
elif ((hour >= 12 && hour < 18)); then
    echo "下午好！欢迎使用脚本！"
else
    echo "晚上好！欢迎使用脚本！"
fi
# 检查 Docker 是否安装
if command -v docker > /dev/null; then
  # 获取磁盘空间信息
  df_info=$(df -h /)
    
  # 解析磁盘空间信息
  partition=$(echo "$df_info" | awk 'NR==2{print $1}')
  used=$(echo "$df_info" | awk 'NR==2{print $3}')
  available=$(echo "$df_info" | awk 'NR==2{print $4}')
  total=$(echo "$df_info" | awk 'NR==2{print $2}')
  percent=$(echo "$df_info" | awk 'NR==2{print $5}')
  # 保存life_time的值到变量lifetime中
  lifetime=$(cat /sys/class/mmc_host/mmc0/mmc0\:0001/life_time)
  # 输出磁盘空间信息
  printf "磁盘分区：%s | 已用空间：%s | 可用空间：%s | 总共空间：%s | 参考寿命：%s | 使用比例：%s\n" "$partition" "$used" "$available" "$total" "$lifetime" "$percent" 

  # 获取当前系统的网络接口名称
  interface=$(ip route | awk '/^default/ {print $5}')

  # 获取当前网络接口的总共使用流量
  rx=$(cat /sys/class/net/${interface}/statistics/rx_bytes)
  tx=$(cat /sys/class/net/${interface}/statistics/tx_bytes)

  # 计算总共使用流量
  total=$((rx + tx))

  # 定义流量单位数组
  units=(B KB MB GB TB PB EB ZB YB)
  # 循环遍历流量单位数组，选择合适的单位
  unit=0
  while [ ${total} -gt 1024 ] && [ ${unit} -lt 8 ]; do
      total=$(echo "${total}/1024" | bc)
      unit=$((unit+1))
  done
  # 获取 CPU 温度
  cpu_temp=$(cat /sys/class/thermal/thermal_zone0/temp)

  # 将温度除以 1000，以得到以摄氏度为单位的温度
  cpu_temp_c=$(echo "scale=2; $cpu_temp/1000" | bc)

  # 获取系统内存和交换分区信息，并将结果存储在变量中
  mem_info=$(free -h | awk 'NR==2{printf "%s/%s\n", $7, $2}')

  # 获取所有 zram 设备的使用情况，并将结果存储在变量中
  zram_info=$(sudo zramctl | awk 'NR>1{printf "%s/%s（%s，%s/%s/%s） ", $4, $3, $1, $2, $5, $7}')

  # 执行 swapon -s 命令，并将结果存储到变量中
  swap_info=$(swapon -s)

  # 提取 /swapfile 的大小和使用情况
  swapfile_size=$(echo "$swap_info" | grep '/swapfile' | awk '{print $3}')
  swapfile_used=$(echo "$swap_info" | grep '/swapfile' | awk '{print $4}')
  # 将 /swapfile 的大小和使用情况转换为 MB
  swapfile_size_mb=$(echo "scale=2; $swapfile_size/1024" | bc)
  swapfile_used_mb=$(echo "scale=2; $swapfile_used/1024" | bc)

  # 输出总共使用流量
  echo "使用的流量：${total} ${units[$unit]}，CPU 温度为：$cpu_temp_c°C，可用/总共: $mem_info，swap：$swapfile_used_mb/$swapfile_size_mb MB，zram ：$zram_info"
  
  if sudo systemctl is-active --quiet docker; then
      # 获取所有容器信息
      container_info=$(docker ps -a --format "{{.Names}}|{{.State}}")
      # 循环遍历所有容器信息，输出到一行中，并用竖线隔开
      output=""
      for info in $container_info
      do
          # 提取容器名称和状态信息
          name=$(echo $info | cut -d "|" -f 1)
          state=$(echo $info | cut -d "|" -f 2)
          # 检查容器状态是否为 running
          if [[ $state == "running" ]]; then
              # 如果容器正在运行，标记为绿色
              output+="\033[32m$name\033[0m | "
          else
              # 如果容器未运行，使用黄色
              output+="\033[33m$name\033[0m | "
          fi
      done
      # 去掉输出字符串末尾的竖线和空格
      output=${output% | }
      # 输出所有容器名称
      # 检查变量 $output 是否为空
      if [ -z "$output" ]; then
        echo -e "\e[32mDocker服务已安装但是没有安装容器，输入 1 选择一个喜欢的吧\e[0m"
      else
        echo -e "容器状态：$output"
      fi
  else
      echo "Docker 未运行，请启动 Docker 服务。"
  fi
else
  echo "Docker没有安装"
fi
echo "请选择要执行的操作："
echo "1. 安装工具"
echo "2. 其他命令"
echo "3. 快捷命令"
echo "   a. 关闭LED"
echo "   b. 清理垃圾&压缩系统"
echo "   c. 查看网络信息"
echo "   d. 查看系统状态"
# 将输入3更改为4gwifi设备的热点设置和apn设置
clean_commands="apt-get clean
journalctl --vacuum-size=5M
echo > /var/log/syslog
echo > /var/log/syslog.1
echo > /var/log/mail.log.1
echo > /var/log/mail.info.1
echo > /var/log/mail.warn.1
echo > /var/log/mail.err.1
echo > /var/log/mail.log
echo > /var/log/mail.info
echo > /var/log/mail.warn
echo > /var/log/mail.err
echo "清理垃圾完成""

read -p "请输入选项（1、2、3、3a、3b、3c、3d）：" option

if [ "$option" == "1" ]; then
  echo "请选择要执行的操作："
  echo "a. 安装Docker"
  echo "b. 安装ql"
  echo "c. 安装1Panel"
  echo "d. 安装bt"
  echo "e. 安装Aria2"
  echo "f. 安装Alist"
  echo "g. 安装CasaOS"
  echo "h. 安装qiandao"
  echo "i. 安装UnblockNeteaseMusic"
  echo "j. 安装Hsaa"
  read -p "请输入字母安装或者回车管理容器：" install_option

  if [ "$install_option" == "a" ]; then
    echo "请选择安装docker的镜像源（可能需要稳定的网络环境）："
    echo "1. 使用Docker官方源"
    echo "2. 使用阿里云镜像源"
    echo "3. 使用DaoCloud镜像源"
    echo "4. 移动docker目录"
    echo "5. 删除Docker及其相关文件和设置"
    read -p "请输入选项（1、2、3、4）：" option
    if [ "$option" == "1" ]; then
    echo "从Docker官方安装Docker"
    curl -fsSL https://get.docker.com -o get-docker.sh
    sudo sh get-docker.sh
    elif [ "$option" == "2" ]; then
      echo "从阿里云安装Docker"
      curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
    elif [ "$option" == "3" ]; then
      echo "从DaoCloud安装Docker"
      curl -sSL https://get.daocloud.io/docker | sh
    elif [ "$option" == "4" ]; then
      echo "拉取脚本中，执行迁移操作可能会出现问题，自行解决"
      sudo curl -sSL https://raw.githubusercontent.com/xiezh123/132/main/3 -o /root/Quick/3 && sudo bash /root/Quick/3
    elif [ "$option" == "5" ]; then
      echo "确认删除 Docker 及其相关文件和设置（如需恢复请更新软件包，如安装docker—ce）"
      sudo docker stop $(sudo docker ps -aq)
      sudo systemctl stop docker && sudo apt-get purge docker-ce docker-ce-cli containerd.io && sudo rm -rf /var/lib/docker /etc/docker && sudo groupdel docker && sudo userdel -r docker && sudo rm -rf /etc/systemd/system/docker.service.d /etc/systemd/system/containerd.service.d /lib/systemd/system/docker.service /lib/systemd/system/containerd.service
    echo "Docker 已被删除"
    else
      echo "无效的选项"
      exit 1
    fi

    echo "启用 Docker 服务..."
    sudo systemctl enable docker
    echo -e "\e[33m请查看 Docker 守护进程的状态信息，出现 \e[32mActive: active (running)\e[33m 即可，安装出错请尝试到：脚本>2>a，修复软件包或更换源\e[0m"
    sudo systemctl start docker && sleep 3
    systemctl status docker
  elif [ "$install_option" == "b" ]; then
    echo "请选择您要安装的版本："
    echo "1. 安装 Debian 版本"
    echo "2. 安装正式版"
    echo "3. 安装 2.10.13 稳定版"
    echo "4. 进入容器"
    source_dir="/srv/ql/scripts"
    target_dir="/root/青龙脚本"
    read panel_option

    if [ "$panel_option" == "1" ]; then
        echo "安装 Debian 版本..."
        ## 执行安装命令
        docker pull whyour/qinglong:debian && sleep 2
        docker run -dit \
        -v /srv/ql:/ql/data \
        -p 5700:5700 \
        --name qinglong \
        --hostname qinglong \
        --restart always \
        --cpus 3 \
        whyour/qinglong:debian &&
        ln -s "$source_dir" "$target_dir"
    elif [ "$panel_option" == "2" ]; then
        echo "安装正式版..."
        ## 执行安装命令
        docker run -dit \
        -v /srv/ql:/ql/data \
        -p 5700:5700 \
        --name qinglong \
        --hostname qinglong \
        --restart always \
        --cpus 3 \
        whyour/qinglong:latest &&
        ln -s "$source_dir" "$target_dir"
    elif [ "$panel_option" == "3" ]; then
        echo "安装 2.10.13 稳定版..."
        ## 执行安装命令
        docker run -dit \
        -v /srv/ql/config:/ql/config \
        -v /srv/ql/log:/ql/log \
        -v /srv/ql/db:/ql/db \
        -v /srv/ql/scripts:/ql/scripts \
        -v /srv/ql/jbot:/ql/jbot \
        -v /srv/ql/repo:/ql/repo \
        -v /srv/ql/ninja:/ql/ninja \
        -v /srv/ql/raw:/ql/raw \
        -p 5960:5700 \
        -p 5701:5701 \
        -e ENABLE_HANGUP=true \
        -e ENABLE_WEB_PANEL=true \
        --name ql \
        --hostname ql \
        --privileged=true \
        --restart always \
        --cpus 3 \
        whyour/qinglong:2.10.13 &&
        ln -s "$source_dir" "$target_dir"
    elif [ "$panel_option" == "4" ]; then
        echo "进入容器，按住 Ctrl 和 PQ 退出容器，执行 ql -l check 修复面板"
        echo "2.10.13 稳定版执行 docker exec -it qinglong bash -c "$(curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/FlechazoPh/QLDependency/main/Shell/QLOneKeyDependency.sh | sh)"
 安装依赖，如果查看不全，自行打开脚本查看"
        docker exec -it qinglong /bin/bash
    else
        echo "无效的选项，退出脚本"
    fi
  elif [ "$install_option" == "c" ]; then
    echo "安装1Panel面板"
    echo "如果需要备份数据，可以将其安装在/srv目录下"
    curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh && bash quick_start.sh
    # 删除名称包含关键字1panel的文件或文件夹
    find /root -maxdepth 1 -name "*1panel*" -exec rm -rf {} +
    # 删除名为quick_start.sh的文件
    rm -f /root/quick_start.sh
  elif [ "$install_option" == "d" ]; then
    echo "安装宝塔开心版，安装完成后终端执行<bt>自行更改"
    wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh && sudo bash install.sh
  elif [ "$install_option" == "e" ]; then
    echo "安装Aria2"
    apt-get update
    apt-get install -y aria2
  elif [ "$install_option" == "f" ]; then
    echo "安装Alist网盘,IP:5244,帐密请查看输出内容"
    curl -fsSL "https://alist.nn.ci/v3.sh" | bash -s install
  elif [ "$install_option" == "g" ]; then
    echo "安装CasaOS个人云,IP"
    wget https://get.casaos.io -O casaos.sh && bash casaos.sh
  elif [ "$install_option" == "h" ]; then
    echo "安装qiandao,IP:8923"
    docker run --restart=always -d --name qiandao -p 8923:80 -v /srv/qiandao/config:/usr/src/app/config --cpus 3 a76yyyy/qiandao:lite-latest
  elif [ "$install_option" == "i" ]; then
    echo "安装网易云音乐解灰,代理端口6666"
    # athr=nondanee && img=unblockneteasemusic && \
    athr=pan93412 && img=unblock-netease-music-enhanced && \
    docker rm -f $img 2>/dev/null || true && \
    docker rmi -f $athr/$img 2>/dev/null || true && \
    docker run -d \
    --name $img \
    --restart always \
    -p 6666:8080 \
    $athr/$img \
    -p 8080:8081 \
    -s -e https://music.163.com -f 59.111.19.33 \
    -o kuwo qq
  elif [ "$install_option" == "j" ]; then
    sudo docker run -d --name hass --restart=always -p 8123:8123 -v /srv/hass:/config --cpus 3 \ homeassistant/home-assistant
    echo "端口：8123"
  else
    echo "选项不存在"
    # 检查 Docker 是否已安装
    if ! command -v docker &> /dev/null; then
        echo "要求安装 Docker。"
        # 检查 byobu 是否已安装
        if dpkg -s byobu &> /dev/null; then
            echo "不要急，能跑等就行，OK吗？"
            sleep 3
            bash <(curl -sSL https://linuxmirrors.cn/docker.sh)
            z
        else
            echo "系统似乎没有更新，请先更新系统"
            apt update && #apt upgrade
            apt-get install byobu -y
            if dpkg -s byobu &> /dev/null; then
                byobu-enable
                sleep 1
                echo "安装ssh托管服务完成，请关闭当前会话重新连接。需要完整更新请执行 apt upgrade 或者重新执行脚本重复步骤安装docker"
            else
                echo "该死的，毁灭吧！！！啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊（*……%￥#"
            fi
        fi
        exit 1
    else
        # 检查 Docker 服务是否正在运行
        if ! systemctl is-active --quiet docker; then
            read -t 5 -p "Docker 未运行，是否启动 Docker 服务？[回车键确认，5秒超时]: " start_choice
            if [ -z "$start_choice" ]; then
                sudo systemctl start docker
                echo "Docker 服务已启动。"
            else
                echo "未启动 Docker 服务。"
                exit 1
            fi
        fi
    fi

    dockerbackupfiles
  fi
elif [ "$option" == "2" ]; then
  echo "请选择要执行的操作："
  echo "a. 检查并修复软件包"
  echo "b. 关机"
  echo "c. 禁用系统日志"
  echo "d. 深度清理文件"
  echo "e. 添加主机模式"
  echo "f. 更改CPU频率"
  echo "g. 查看emmc"
  echo "h. LED控制选项"
  echo "i. 安装桌面（xfce）"
  echo "j. 添加push推送"
  echo "k. 更改交换分区大小"
  read -p "请输入选项（a、b、c、d、e）：" check_option

  if [ "$check_option" == "a" ]; then
    echo "正在检查并更新软件包..."
    echo -e '\xE2\xA0\x84\xE2\xA0\x84\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA0\x98\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xA7\xE2\xA3\x9B\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA0\xA4\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBF\xE2\xA3\xBD\xE2\xA1\x86\xE2\xA0\x84\xE2\xA0\x84'
    apt-get check && apt-get -f install
    sleep 1
    sudo apt-get update && sleep 2 && sudo apt --fix-broken install
  elif [ "$check_option" == "b" ]; then
    echo "正在关机..."
    sudo shutdown -h now
  elif [ "$check_option" == "c" ]; then
    echo "正在清空系统日志..."
    sudo systemctl stop rsyslog && sudo systemctl disable rsyslog && sudo systemctl stop systemd-journald && sudo systemctl disable systemd-journald && sudo cat /dev/null > /var/log/syslog && sudo cat /dev/null > /var/log/messages && sudo cat /dev/null > /var/log/auth.log && sudo cat /dev/null > /var/log/user.log && sudo cat /dev/null > /var/log/kern.log && sudo cat /dev/null > /var/log/mysql/error.log && sudo find /var/log -type f -delete && sudo rm -rf /var/log/* && sudo rm -rf /tmp/* && sudo rm -rf /var/tmp/*
  elif [ "$check_option" == "d" ]; then
    read -p "警告：执行此操作可能会造成系统不稳定甚至崩溃，按回车键确认继续执行，出现英文提示时CTRL&C退出：" confirm
    if [ -z "$confirm" ]; then
      echo "正在深度清理文件..."
        if ! command -v bleachbit &> /dev/null
  then
      echo "Bleachbit not found. Installing..."
      sudo apt-get update && sudo apt-get install -y bleachbit
  fi

  echo "Cleaning system..."
  bleachbit --clean system.*
    else
      echo "已取消执行操作"
    fi
  elif [ "$check_option" == "e" ]; then
    read -p "警告：执行此操作将向 rc.local 文件添加一行命令，可能会影响系统稳定性。按回车键确认继续执行：" confirm
    if [ -z "$confirm" ]; then
      echo "正在添加主机模式..."
      sudo sed -i '/exit 0/i\sleep 45\necho host > /sys/kernel/debug/usb/ci_hdrc.0/role' /etc/rc.local
    else
      echo "已取消执行操作"
    fi
  elif [ "$check_option" == "f" ]; then
  # 检查 cpufrequtils 是否已安装，如果未安装则自动安装
  if ! dpkg -s cpufrequtils > /dev/null 2>&1 ; then
      echo "cpufrequtils 尚未安装，正在安装..."
      sudo apt-get install cpufrequtils -y
  fi

  # 显示选择菜单
  echo "请选择 CPU 频率："
  echo "1. 动态调整"
  echo "2. 800 MHz"
  echo "3. 1000 MHz"
  echo "4. 1.20 GHz"
  echo "5. 1.40 GHz"
  echo "6. 1.60 GHz"
  echo "7. 1.80 GHz"
  echo "8. 2.00 GHz"
  echo "9. 2.10 GHz"

  # 读取用户输入
  read -p "请输入数字 [1-9]: " choice

  # 根据用户输入修改 CPU 频率
  case $choice in
    1) sudo cpufreq-set -g ondemand ;;
    2) sudo cpufreq-set -c 0 -f 800000 ;;
    3) sudo cpufreq-set -c 0 -f 1000000 ;;
    4) sudo cpufreq-set -c 0 -f 1200000 ;;
    5) sudo cpufreq-set -c 0 -f 1400000 ;;
    6) sudo cpufreq-set -c0 -f 1600000 ;;
    7) sudo cpufreq-set -c 0 -f 1800000 ;;
    8) sudo cpufreq-set -c 0 -f 2000000 ;;
    9) sudo cpufreq-set -c 0 -f 2100000 ;;
    *) echo "错误的输入" ;;
  esac

  echo "CPU 频率已修改为："
  sudo cpufreq-info | grep "current CPU frequency"
  elif [ "$check_option" == "g" ]; then
    cat /sys/class/mmc_host/mmc0/mmc0\:0001/life_time
  elif [ "$check_option" == "h" ]; then
    echo "来自酷安 https://www.coolapk.com/feed/42477870? "
    sleep 3
    bash -c "$(curl -L gitee.com/ojf6ii/led-control-script/raw/master/led.sh)"
  elif [ "$check_option" == "i" ]; then
    read -p "需要4g左右空间，安装速度由棒子体质决定，输入x返回会话，回车继续"
    # 检查screen和git是否已安装
    if ! command -v screen &> /dev/null
    then
        echo "安装screen"
        sudo apt-get install screen -y
    else
        echo "安装工具1"
    fi
    if [ -e "/root/Desktop.sh" ]; then
      echo "文件 /root/Desktop.sh 存在."
    else
      echo '#!/bin/bash
      sudo apt-get update && sudo apt-get install xrdp -y && sleep 3
      sudo service xrdp start -y && apt-get install task-xfce-desktop -y && sleep 3
      sudo apt-get install -y openssh-server
      sudo systemctl start ssh
      btrfs filesystem defragment -r -v -czstd / && sleep 3
      wget https://dldir1.qq.com/qqfile/qq/QQNT/ad5b5393/linuxqq_3.1.2-13107_arm64.deb && sudo dpkg -i linuxqq_3.1.2-13107_arm64.deb
      sudo rm /root/linuxqq_3.1.2-13107_arm64.deb
      sudo rm /root/Desktop.sh
      sudo rm /usr/local/bin/x' > Desktop.sh
    fi
    sleep 2
    sudo chmod +x /root/Desktop.sh
    # 定义文件路径
    FILE_PATH="/usr/local/bin/x"
    FILE="screen -d -r Desktop"
    # 创建文件并写入命令
    echo "$FILE" > "$FILE_PATH"
    sudo chmod +x /usr/local/bin/x
    #新建窗口
    screen -dmS Desktop bash -c "bash /root/Desktop.sh"
    sleep 2
    $FILE
    GREEN='\033[0;32m'
NC='\033[0m' # No Color
echo -e "${GREEN}请使用远程桌面客户端连接到服务器，使用root用户名和密码登录。${NC}"
  elif [ "$check_option" == "j" ]; then
    # 设置拉取次数
    max_attempts=2
    attempts=0

    # 设置文件名和路径
    file_name="push"
    file_path="/srv/$file_name"
    # 检查是否能够 ping 通 raw.githubusercontent.com
    ping -c 1 raw.githubusercontent.com > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        url="https://raw.githubusercontent.com/xiezh123/132/main/6.sh"
    else
        url="https://raw.staticdn.net/xiezh123/132/main/6.sh"
    fi
    # 尝试拉取文件
    while [ $attempts -lt $max_attempts ]; do
        attempts=$((attempts+1))
        echo "正在尝试从 $url 拉取文件，第 $attempts 次尝试..."
        if curl -# -o "$file_path" "$url" > /dev/null 2>&1; then
            if [ -s "$file_path" ]; then
                echo "成功拉取文件 $file_name 到 $file_path"
                while true; do
                  # 获取用户输入的MyToken值
                  echo -e "\033[33m请前往push官方网站，登录并且复制Token\033[0m"
                  read -p "请输入Token值： " -n 32 my_token
                  # 检查输入是否为32位十六进制数字
                  if [[ ! $my_token =~ ^[0-9a-fA-F]{32}$ ]]; then
                    echo -e "\033[31m输入不正确，请输入32位十六进制数字。\033[0m"
                  else
                    # 将MyToken值写入push文件
                    sed -i "s/MyToken=\"[0-9a-fA-F]*\"/MyToken=\"$my_token\"/" /srv/push
                    echo "MyToken值已更新为：$my_token"
                    break
                  fi
                done
                bash /srv/push
                echo -e "\033[32m已经执行推送，请查看是否成功。\033[0m"
                exit 0
            fi
        fi
    done
    echo "无法拉取文件 $file_name"
    exit 1
  elif [ "$check_option" == "k" ]; then
    valid_input=false
    while [ "$valid_input" = false ]; do
        read -p "请输入交换分区大小（MB）: " input
        # 检查输入是否只包含0到9以内的字符并且不超过5000
        if [[ "$input" =~ ^[0-9]+$ ]] && [ "$input" -le 5000 ]; then
            valid_input=true
        else
            echo "输入无效，请重新输入。"
        fi
    done
    # 将 /etc/environment 文件中的变量名 swap 更改为 vswap，并更新其值为用户输入的值
    sudo sed -i "s/^swap=.*$/vswap=$input/" /etc/environment
    echo -e "\033[1;33m已经提交更改，重启后稍加等待即可\033[0m"
    read -p "回车重启..."
    f
  else
    echo "选项不存在"
  fi

elif [[ "$option" == "3" ]]; then # 开热点####################################################################################################################################
  check_sys_hotspot() {
          # 提示用户输入热点名称和密码
          if grep -q "4Gwifi=" /etc/environment; then
              # 从文件中读取变量内容
              read -t 10 -n 1 -s -r -p "检查到你已经设置热点，重新配置吗？（按回车键继续，10秒后自动退出）"
              # 检查用户是否回车确认或等待超时
              if [[ $? -ne 0 ]]; then
                  echo "等待超时或无效按键。脚本已退出。"
                  exit 1
              fi
              hotspot="$hotspot" nmcli connection down "$hotspot"
          else
              read -t 10 -n 1 -s -r -p "开机自启的，确定需要设置热点吗？？（按回车键继续，10秒后自动退出）"
              # 检查用户是否回车确认或等待超时
              if [[ $? -ne 0 ]]; then
                  echo "等待超时或无效按键。脚本已退出。"
                  exit 1
              fi
          fi
          # 读取并验证热点密码
          while true; do
              read -p "请输入热点名称: " hotspot_ssid
              read -p "请输入热点密码（只能为数字且不能低于8位数）: " hotspot_password

              # 验证密码是否只包含数字
              if ! [[ $hotspot_password =~ ^[0-9]+$ ]]; then
                  echo "密码只能为数字，请重新输入。"
                  continue
              fi

              # 验证密码是否少于8位数
              if (( ${#hotspot_password} < 8 )); then
                  echo "密码不能少于8位数，请重新输入。"
                  continue
              fi

              break
          done
          # 提示用户确认输入
          echo "您输入的热点名称为: $hotspot_ssid"
          echo "您输入的热点密码为: $hotspot_password"
          read -t 10 -n 1 -s -r -p "请确认输入是否正确，按回车键继续，或者等待10秒后重新输入..."
          # 如果不一致则启用热点并且向 $hotspot 写入新的 UUID
          check_update_hotspot() {
              local var1=$1
              local var2=$2
              if [[ -f "/etc/environment" ]]; then
                  # 检查文件内容是否包含 hotspot 变量
                  if grep -q "^hotspot=" "/etc/environment"; then
                      sed -i 's/^hotspot=.*/hotspot=0/' /etc/environment
                  else
                      sudo sh -c 'echo "hotspot=0" >> /etc/environment'
                  fi
              fi
              output3=$(nmcli d wifi hotspot ifname wlan0 con-name wifi ssid "$var1" band bg channel 11 password "$var2" 2>&1 | tee /dev/tty) # 更改名字密码为变量
              # 提取连接的 UUID
              uuid1=$(echo "${output3}" | awk '{print $2}')
              # 去除双引号和前缀 "wlan0"
              uuid1=${uuid1//\"/}
              uuid1=${uuid1#wlan0}
              # 去除另一行的 "nmcli"
              uuid1=$(echo "$uuid1" | sed '/^$/d' | sed 's/nmcli//g')
              # 将 UUID 写入文件
              sed -i "s/^hotspot=.*/hotspot=$(echo "$uuid1" | sed 's/\//\\\//g')/g" /etc/environment
              sleep 3
              nmcli dev wifi show-password
              echo "出现问题请重启"
          }
          # 检查用户是否回车确认或等待超时
          if [[ $? -ne 0 ]]; then
              echo "等待超时或无效按键。请重新运行脚本输入热点名称和密码。"
              exit 1
          fi
          # 检查 /etc/environment 文件是否含有变量 4Gwifi
          if grep -q "4Gwifi=" /etc/environment; then
              # 更改变量内容为用户输入的热点名称和密码
              sed -i "s|4Gwifi=.*|4Gwifi=$hotspot_ssid//$hotspot_password|" /etc/environment
              check_update_hotspot "$hotspot_ssid" "$hotspot_password"
          else
              # 创建变量并设置内容为用户输入的热点名称和密码
              echo "4Gwifi=$hotspot_ssid//$hotspot_password" >> /etc/environment
              check_update_hotspot "$hotspot_ssid" "$hotspot_password"
          fi
  }
  output=$(mmcli -m 0)
  # 提取所需内容
  filtered_output=$(echo "$output" | awk '/Status/,/signal quality/ {print}') #状态
  signal_quality=$(echo "$filtered_output" | awk -F 'signal quality: ' '/signal quality:/{print $2}') #信号
  network_type=$(echo "$filtered_output" | awk -F 'access tech: ' '/access tech:/{print $2}') #网络
  power_state=$(echo "$filtered_output" | awk -F 'power state: ' '/power state:/{print $2}') #开关
  # 输出设备内容
  lock=$(echo "$filtered_output" | awk -F 'lock: ' '/lock:/{print $2}')
  equipment_id=$(mmcli -m 0 | awk -F ': ' '/equipment id:/ {print $2}')
  device_model=$(mmcli -m 0 | awk -F 'firmware revision: ' '/firmware revision:/ {print $2}' | awk '{print $1}')
  echo "当前设备是：$device_model，设备MEID: $equipment_id，SIM锁定状态：$lock"
  # 去除颜色控制码
  filtered_output=$(echo "$filtered_output" | sed 's/\x1B\[[0-9;]\+[A-Za-z]//g')
  # 检查状态并进行相应提示
  if echo "$filtered_output" | grep -q -E "state:[[:space:]]+connected"; then
      echo "当前状态：4g网络已连接"
      echo "信号质量：$signal_quality"
      echo "网络类型：$network_type"
      echo "电源状态：$power_state"
      read -p "回车配置热点..."
      check_sys_hotspot
  elif echo "$filtered_output" | grep -q -E "state:[[:space:]]+registered"; then
      echo "当前网络已注册，执行 nmtui 前往启用即可"
      echo "信号质量：$signal_quality"
      echo "网络类型：$network_type"
      echo "电源状态：$power_state"
  elif echo "$filtered_output" | grep -q -E "state:[[:space:]]+failed"; then
      echo "没有信号，请检查基带是否已经更换或者插入SIM卡"
      check_sys_hotspot
  elif echo "$filtered_output" | grep -q -E "state:[[:space:]]+enabled"; then
      echo "请检查基带是否已经更换(使用刷机包/modem解压并且覆盖到Debian//lib/firmware目录下）"
      echo "信号质量：$signal_quality"
      echo "网络类型：$network_type"
      echo "电源状态：$power_state"
  else
      mmcli -m 0
      echo "无法确定当前状态，请查看（如果是黄色的 connected 重启试试"
  fi
elif [[ "$option" == "3a" ]]; then
  # 显示 LED 控制菜单
  echo "请选择 LED 控制选项：（回车关闭）"
  echo "1. 保留WiFi（默认情况）"
  echo "2. 蓝绿互换"
  echo "3. 关闭/自启"
  read -r led_option
  
  # 处理 LED 控制选项
  case "$led_option" in
    1)
      # 关闭其他 LED
      echo 0 > /sys/class/leds/mmc0\:\:/brightness #红灯
      echo none > /sys/class/leds/green\:internet/trigger #绿灯
      ;;
    2)
      # LED 互换
      echo heartbeat > /sys/class/leds/blue\:wifi/trigger
      echo phy0tx > /sys/class/leds/green\:internet/trigger
      ;;
    3)
      # LED 关闭/开启
      # 读取 /etc/environment 文件中的 LED 环境变量的值
      led_value=$(grep -oP "(?<=LED=)[0-1]" /etc/environment)
      
      if [[ "$led_value" == "1" ]]; then
          # 将 LED 环境变量的值从 1 修改为 0
          sudo sed -i 's/LED=1/LED=0/' /etc/environment
          echo "开机完成后关闭led"
      elif [[ "$led_value" == "0" ]]; then
          # 将 LED 环境变量的值从 0 修改为 1
          sudo sed -i 's/LED=0/LED=1/' /etc/environment
          echo "开机保持led开启"
      else
          echo "未找到相关配置，重新更新试试？"
      fi
      ;;
    *)
      # 默认情况：关闭 LED
      echo "关闭 LED"
      echo 0 > /sys/class/leds/mmc0\:\:/brightness #红灯
      echo none > /sys/class/leds/blue\:wifi/trigger #蓝灯
      echo none > /sys/class/leds/green\:internet/trigger #绿灯
      ;;
  esac
elif [[ "$option" == "3b" ]]; then 
  echo "清理垃圾"
  eval "$clean_commands"

  ROOT_PARTITION=$(mount | grep "on / " | cut -d' ' -f1)
  if [ "$(lsblk -o FSTYPE "$ROOT_PARTITION" | tail -n1)" == "btrfs" ]; then 
    echo "根文件系统为 btrfs，执行相关操作"
    btrfs filesystem defragment -r -v -czstd /
  else 
    echo "根文件系统不是 btrfs，跳过相关操作"
  fi 
elif [[ "$option" == "3c" ]]; then 
  echo "查看网络信息"
  ip addr show
  echo -e "\e[32m--------测试百度----------------------------------------------------------------------------------------------------------------------------------------------------\e[0m"
  ping -c 4 baidu.com
  echo -e "\e[32m---------测试谷歌---------------------------------------------------------------------------------------------------------------------------------------------------\e[0m"
  ping -c 4 google.com
  echo -e "\e[32m------------查看接口------------------------------------------------------------------------------------------------------------------------------------------------\e[0m"
  # 获取网络接口数量
  interface_count=$(nmcli device status | awk 'NR>1 {print $1}' | wc -l)
  # 输出网络接口数量的提示
  echo "网络接口数量: $interface_count"
  echo "接口名称列表:"
  # 获取设备列表及其对应的类型
  devices=($(nmcli device status | awk 'NR>1 {print $1}'))
  device_types=($(nmcli device show | awk '/GENERAL.DEVICE:/ {getline; print $2}'))
  # 遍历设备列表
  for ((i=0; i<interface_count; i++)); do
    # 输出设备名称和类型
    device=${devices[$i]}
    device_type=${device_types[$i]}
    if [ "$device_type" == "ethernet" ]; then
      echo -e "接口\e[33m$device\e[0m正在被ethernet使用"
    elif [ "$device_type" == "wifi" ]; then
      echo -e "接口\e[33m$device\e[0m正在被wifi使用"
    elif [ "$device_type" == "gsm" ]; then
      echo -e "接口\e[33m$device\e[0m正在被gsm/modem使用"
    else
      echo "接口$device正在被$device_type使用"
    fi
  done
  echo -e "\e[32m-----------查看基带-------------------------------------------------------------------------------------------------------------------------------------------------\e[0m"
  mmcli -m 0
  echo -e "\e[32m-------------检查完成-------------\e[0m"
  echo -e "\e[32m-----------测试网速（太慢了就退出吧）-------------------------------------------------------------------------------------------------------------------------------------------------\e[0m"
  speedtest-cli
  z
elif [[ "$option" == "3d" ]]; then 
  echo "查看系统状态"
  echo "系统详情：$(uname -a)"
  echo "CPU 信息：$(lscpu)"
  echo "内存占用情况：$(free -h)"
  echo "Swap 占用情况：$(swapon -s)"
  echo "磁盘挂载情况：$(lsblk)"
  echo "存储占用情况：$(df -h)"
  # ANSI 转义序列，用于添加颜色
  green='\033[0;32m'
  yellow='\033[0;33m'
  blue='\033[0;34m'
  magenta='\033[0;35m'
  cyan='\033[0;36m'
  reset='\033[0m' # 重置颜色
  
  # 获取所有正在运行的容器的ID和名称
  container_info=$(docker ps --format '{{.ID}}|{{.Names}}')

  # 循环遍历容器ID和名称，并输出容器信息
  while IFS='|' read -r container_id container_name; do
    echo -e "${green}容器ID：$container_id${reset}"
    echo -e "${yellow}容器名称：$container_name${reset}"

    # 输出容器状态信息
    echo -e "${blue}状态：$(docker inspect --format='{{.State.Status}}' $container_id)${reset} | ${magenta}创建时间：$(docker inspect --format='{{.Created}}' $container_id)${reset} | ${cyan}IP地址：$(docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $container_id)${reset}"
    echo ""

    # 输出容器端口映射信息
    echo -e "${blue}端口映射：${reset}"
    docker port $container_id
    echo ""

    # 输出容器挂载的卷信息
    echo -e "${blue}挂载的卷：${reset}"
    docker inspect --format='{{range .Mounts}}{{printf "%s:%s\n" .Type .Source}}{{end}}' $container_id
    echo ""

  done <<< "$container_info"
else
  echo "选项不存在，拉取其他脚本"
  curl -sS -O https://raw.githubusercontent.com/kejilion/sh/main/kejilion.sh && chmod +x kejilion.sh && ./kejilion.sh
fi
